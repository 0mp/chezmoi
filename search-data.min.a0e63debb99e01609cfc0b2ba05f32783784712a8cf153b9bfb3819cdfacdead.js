'use strict';(function(){const indexCfg=;indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/categories/','title':"Categories",'content':""});index.add({'id':1,'href':'/docs/changes/','title':"Changes",'content':" Changes  Upcoming  gpgRecipient config variable changing to gpg.recipient   Upcoming gpgRecipient config variable changing to gpg.recipient The gpgRecipient config varaible is changing to gpg.recipient. To update, change your config from:\ngpgRecipient = \u0026quot;...\u0026quot;  to:\n[gpg] recipient = \u0026quot;...\u0026quot;  Support for the gpgRecipient config variable will be removed in version 2.0.0.\n"});index.add({'id':2,'href':'/docs/contributing/','title':"Contributing",'content':" Contributing Guide  Getting started Developing locally Contributing changes Managing releases Packaging  Getting started chezmoi is written in Go and development happens on GitHub. The rest of this document assumes that you\u0026rsquo;ve checked out chezmoi locally.\nDeveloping locally chezmoi is a standard Go project, using standard Go tooling, with a few extra tools. Install these extra tools with:\nmake install-tools  Build chezmoi:\ngo build .  Run all tests:\ngo test ./...  Run chezmoi:\ngo run .  Contributing changes Bug reports, bug fixes, and documentation improvements are always welcome. Please open an issue or create a pull request with your report, fix, or improvement.\nIf you want to make a more significant change, please first open an issue to discuss the change that you want to make. Dave Cheney gives a good rationale as to why this is important.\nAll changes are made via pull requests. In your pull request, please make sure that:\n All existing tests pass.\n There are appropriate additional tests that demonstrate that your PR works as intended.\n The documentation is updated, if necessary. For new features you should add an entry in docs/HOWTO.md and a complete description in docs/REFERENCE.md.\n The code is correctly formatted, according to gofumports. You can ensure this by running make format.\n The code passes go vet and golangci-lint. You can ensure this by running make lint.\n The commit messages match chezmoi\u0026rsquo;s convention, specifically that they begin with a capitalized verb in the imperative and give a short description of what the commit does. Detailed information or justification can be optionally included in the body of the commit message.\n Commits are logically separate, with no merge or \u0026ldquo;fixup\u0026rdquo; commits.\n The branch applies cleanly to master.\n  Managing releases Releases are managed with goreleaser.\nTo create a new release, push a tag, eg:\ngit tag -a v0.1.0 -m \u0026quot;First release\u0026quot; git push origin v0.1.0  To run a local \u0026ldquo;snapshot\u0026rdquo; build without publishing:\nmake test-release  Packaging If you plan to package chezmoi for your distibution, then note:\n Please set the version number, git commit, and build time in the binary. This is done by passing the linker flags:\n-X github.com/twpayne/chezmoi/cmd.VersionStr={{ .Version }} -X github.com/twpayne/chezmoi/cmd.Commit={{ .Commit }} -X github.com/twpayne/chezmoi/cmd.Date={{ .Date }}  Please enable CGO, if possible. chezmoi can be built and run without CGO, but the .chezmoi.group template variable may not be set on some systems.\n chezmoi includes a docs command which prints its documentation. By default, the docs are embedded in the binary. You can disable this behaviour, and have chezmoi read its docs from the filesystem by building with the noembeddocs build tag and setting the directory where chezmoi can find them with the -X github.com/twpayne/chezmoi/cmd.DocDir={{ .PathToDocs }} linker flag. For example:\ngo build -tags noembeddocs -ldflags \u0026quot;-X github.com/twpayne/chezmoi/cmd.DocsDir=/usr/share/doc/chezmoi\u0026quot; .   To disable the docs command completely, use the nodocs build tag.\n chezmoi includes an upgrade command which attempts to self-upgrade. You can remove this command completely by building chezmoi with the noupgrade build tag.\n chezmoi includes shell completions in the completions directory. Please include these in the package and install them in the shell-appropriate directory, if possible.\n  "});index.add({'id':3,'href':'/docs/','title':"Docs",'content':""});index.add({'id':4,'href':'/docs/faq/','title':"FAQ",'content':" Frequently Asked Questions  How can I quickly check for problems with chezmoi on my machine? What are the consequences of \u0026ldquo;bare\u0026rdquo; modifications to the target files? If my .zshrc is managed by chezmoi and I edit ~/.zshrc without using chezmoi edit, what happens? How can I tell what dotfiles in my home directory aren\u0026rsquo;t managed by chezmoi? Is there an easy way to have chezmoi manage a subset of them? If there\u0026rsquo;s a mechanism in place for the above, is there also a way to tell chezmoi to ignore specific files or groups of files (e.g. by directory name or by glob)? If the target already exists, but is \u0026ldquo;behind\u0026rdquo; the source, can chezmoi be configured to preserve the target version before replacing it with one derived from the source? How do I only run a script when a file has changed? I\u0026rsquo;ve made changes to both the destination state and the source state that I want to keep. How can I keep them both? chezmoi\u0026rsquo;s source file naming system cannot handle all possible filenames gpg encryption fails. What could be wrong? What inspired chezmoi? Can I use chezmoi outside my home directory? Where does the name \u0026ldquo;chezmoi\u0026rdquo; come from? What other questions have been asked about chezmoi? Where do I ask a question that isn\u0026rsquo;t answered here?  How can I quickly check for problems with chezmoi on my machine? Run:\nchezmoi doctor  Anything ok is fine, anything warning is only a problem if you want to use the related feature, and anything error indicates a definite problem.\nWhat are the consequences of \u0026ldquo;bare\u0026rdquo; modifications to the target files? If my .zshrc is managed by chezmoi and I edit ~/.zshrc without using chezmoi edit, what happens? chezmoi will overwrite the file the next time you run chezmoi apply. Until you run chezmoi apply your modified ~/.zshrc will remain in place.\nHow can I tell what dotfiles in my home directory aren\u0026rsquo;t managed by chezmoi? Is there an easy way to have chezmoi manage a subset of them? chezmoi unmanaged will list everything not managed by chezmoi. You can add entire directories with chezmoi add -r.\nIf there\u0026rsquo;s a mechanism in place for the above, is there also a way to tell chezmoi to ignore specific files or groups of files (e.g. by directory name or by glob)? By default, chezmoi ignores everything that you haven\u0026rsquo;t explicitly chezmoi added. If have files in your source directory that you don\u0026rsquo;t want added to your destination directory when you run chezmoi apply add them to a .chezmoiignore file (which supports globs and is also a template).\nIf the target already exists, but is \u0026ldquo;behind\u0026rdquo; the source, can chezmoi be configured to preserve the target version before replacing it with one derived from the source? Yes. Run chezmoi add will update the source state with the target. To see diffs of what would change, without actually changing anything, use chezmoi diff.\nHow do I only run a script when a file has changed? A common example of this is that you\u0026rsquo;re using Homebrew and have .Brewfile listing all the packages that you want installed and only want to run brew bundle --global when the contents of .Brewfile changes.\nchezmoi has two types of scripts: scripts that run every time, and scripts that only one when their contents change. chezmoi does not have a mechanism to run a script when an arbitrary file has changed, but there are some ways to achieve the desired behavior:\n Have the script create .Brewfile instead of chezmoi, e.g. in your run_once_install-packages:\n#!/bin/sh cat \u0026gt; $HOME/.Brewfile \u0026lt;\u0026lt;EOF brew \u0026quot;imagemagick\u0026quot; brew \u0026quot;openssl\u0026quot; EOF brew bundle --global  Don\u0026rsquo;t use .Brewfile, and instead install the packages explicitly in run_once_install-packages:\n#!/bin/sh brew install imagemagick || true brew install openssl || true   The || true is necessary because brew install exits with failure if the package is already installed.\n Use a script that runs every time (not just once) and rely on brew bundle --global being idempotent.\n Use a script that runs every time, records a checksum of .Brewfile in another file, and only runs brew bundle --global if the checksum has changed, and updates the recorded checksum after.\n  I\u0026rsquo;ve made changes to both the destination state and the source state that I want to keep. How can I keep them both? chezmoi merge will open a merge tool to resolve differences between the source state, target state, and destination state. Copy the changes you want to keep in to the source state.\nchezmoi\u0026rsquo;s source file naming system cannot handle all possible filenames This is correct. Certain target filenames, for example ~/dot_example, are incompatible with chezmoi\u0026rsquo;s attributes used in the source state.\nThis is a deliberate, practical compromise. Target state metadata (private, encrypted, etc.) need to be stored for each file. Using the source state filename for this means that the contents of the file are untouched, there is no need to maintain the metadata in a separate file, is independent of the underlying filesystem and version control system, and unambiguously associates the metadata with a single file.\nIn practice, dotfile filenames are unlikely to conflict with chezmoi\u0026rsquo;s attributes. If this does cause a genuine problem for you, please open an issue on GitHub.\ngpg encryption fails. What could be wrong? The gpg.recipient key should be ultimately trusted, otherwise encryption will fail because gpg will prompt for input, which chezmoi does not handle. You can check the trust level by running:\ngpg --export-ownertrust  The trust level for the recipient\u0026rsquo;s key should be 6. If it is not, you can change the trust level by running:\ngpg --edit-key $recipient  Enter trust at the prompt and chose 5 = I trust ultimately.\nWhat inspired chezmoi? chezmoi was inspired by Puppet, but created because Puppet is a slow overkill for managing your personal configuration files. The focus of chezmoi will always be personal home directory management. If your needs grow beyond that, switch to a whole system configuration management tool.\nCan I use chezmoi outside my home directory? chezmoi, by default, operates on your home directory, but this can be overridden with the --destination command line flag or by specifying destDir in your config file. In theory, you could use chezmoi to manage any aspect of your filesystem. That said, although you can do this, you probably shouldn\u0026rsquo;t. Existing configuration management tools like Puppet, Chef, Ansible, and Salt are much better suited to whole system configuration management.\nWhere does the name \u0026ldquo;chezmoi\u0026rdquo; come from? \u0026ldquo;chezmoi\u0026rdquo; splits to \u0026ldquo;chez moi\u0026rdquo; and pronouced /ʃeɪ mwa/ (shay-moi) meaning \u0026ldquo;at my house\u0026rdquo; in French. It\u0026rsquo;s seven letters long, which is an appropriate length for a command that is only run occasionally.\nWhat other questions have been asked about chezmoi? See the issues on GitHub.\nWhere do I ask a question that isn\u0026rsquo;t answered here? Please open an issue on GitHub.\n"});index.add({'id':5,'href':'/','title':"Home",'content':" chezmoi Manage your dotfiles across multiple machines, securely.\n What does chezmoi do and why should I use it? What are chezmoi\u0026rsquo;s key features? I already have a system to manage my dotfiles, why should I use chezmoi? How do I start with chezmoi? License  What does chezmoi do and why should I use it? chezmoi helps you manage your personal configuration files (dotfiles) across multiple machines. It is particularly helpful if you have spent time customizing the tools you use (e.g. shells, editors, and version control systems) and want to keep machines running different accounts (e.g. home and work) and/or different operating systems (e.g. Linux and macOS) in sync, while still being able to easily cope with differences from machine to machine.\nchezmoi has particularly strong support for security, allowing you to manage secrets (e.g. passwords, access tokens, and private keys) securely and seamlessly using either gpg encryption or a password manager of your choice.\nIn all cases you only need to maintain a single source of truth: a single branch in a version control system (e.g. git) for everything public and a single password manager for all your secrets, with seamless integration between them.\nIf you do not personalize your configuration or only ever use a single operating system with a single account and none of your dotfiles contain secrets then you don\u0026rsquo;t need chezmoi. Otherwise, read on\u0026hellip;\nWhat are chezmoi\u0026rsquo;s key features?  Flexible: You can share as much configuration across machines as you want, while still being able to control machine-specific details. You only need to maintain a single branch. Your dotfiles can be templates (using text/template syntax). Predefined variables allow you to change behaviour depending on operating system, architecture, and hostname.\n Personal and secure: Nothing leaves your machine, unless you want it to. You can use the version control system of your choice to manage your configuration, and you can write the configuration file in the format of your choice. chezmoi can retrieve secrets from 1Password, Bitwarden, gopass, KeePassXC, LastPass, pass, Vault, your Keychain (on macOS), GNOME Keyring (on Linux), or any command-line utility of your choice. You can encrypt individual files with gpg. You can checkout your dotfiles repo on as many machines as you want without revealing any secrets to anyone.\n Transparent: chezmoi includes verbose and dry run modes so you can review exactly what changes it will make to your home directory before making them. chezmoi\u0026rsquo;s source format uses only regular files and directories that map one-to-one with the files, directories, and symlinks in your home directory that you choose to manage. If you decide not to use chezmoi in the future, it is easy to move your data elsewhere.\n Robust: chezmoi updates all files and symbolic links atomically (using google/renameio). You will never be left with incomplete files that could lock you out, even if the update process is interrupted.\n Declarative: you declare the desired state of files, directories, and symbolic links in your home directory and chezmoi updates your home directory to match that state. What you want is what you get.\n Fast and easy to use: chezmoi runs in fractions of a second and makes most day-to-day operations one line commands, including installation, initialization, and keeping your machines up-to-date.\n  I already have a system to manage my dotfiles, why should I use chezmoi?  If your system is based on copying files with a shell script or creating symlinks (e.g. using GNU Stow) then handling files that vary from machine to machine requires manual work. You might need to maintain separate config files for separate machines, or run different commands on different machines. chezmoi gives you a single command (chezmoi update) that works on every machine.\n If your system is based on using git with a different branches for different machines, then you need manually merge or rebase to ensure that changes you make are applied to each machine. chezmoi uses a single branch and makes it trivial to share common parts while allowing specific per-machine configuration.\n If your system stores secrets in plain text, then your dotfiles repository must be private. With chezmoi you can store secrets in your password manager, so you can make your dotfiles public. You can share your repository between your personal and work machines, without leaving personal secrets on your work machine or work secrets on your personal machine.\n If your system was written by you for your personal use, then it probably has the minimum functionality that you need. chezmoi includes a wide range of functionality out-of-the-box, including dry run and diff modes, conflict resolution, and running scripts.\n All systems suffer from the bootstrap problem: you need to install your system before you can install your dotfiles. chezmoi provides one-line installs, statically-linked binaries, packages for many Linux and BSD distributions, Homebrew formulae, and a initial config file generation mechanism to make overcoming the bootstrap problem as painless as possible.\n  How do I start with chezmoi? Install chezmoi then read the quick start guide. The how-to guide covers most common tasks, and there\u0026rsquo;s the frequently asked questions for specific questions. For a full description of chezmoi, consult the reference. If all else fails, open an issue.\nLicense MIT\n"});index.add({'id':6,'href':'/docs/how-to/','title':"How-To",'content':" How-To Guide  Use a hosted repo to manage your dotfiles across multiple machines Pull the latest changes from your repo and apply them Pull the latest changes from your repo and see what would change, without actually applying the changes Use templates to manage files that vary from machine to machine Create a config file on a new machine automatically Ensure that a target is removed Keep data private  Use Bitwarden to keep your secrets Use gopass to keep your secrets Use gpg to keep your secrets Use KeePassXC to keep your secrets Use a keyring to keep your secrets Use LastPass to keep your secrets Use 1Password to keep your secrets Use pass to keep your secrets Use Vault to keep your secrets Use a generic tool to keep your secrets Use templates variables to keep your secrets  Use scripts to perform actions  Understand how scripts work Install packages with scripts  Import archives Export archives Use a non-git version control system Use a merge tool other than vimdiff Migrate from a dotfile manager that uses symlinks Automatically commit and push changes to your repo  Use a hosted repo to manage your dotfiles across multiple machines chezmoi relies on your version control system and hosted repo to share changes across multiple machines. You should create a repo on the source code repository of your choice (e.g. Bitbucket, GitHub, or GitLab, many people call their repo dotfiles) and push the repo in the source directory here. For example:\nchezmoi cd git remote add origin https://github.com/username/dotfiles.git git push -u origin master exit  On another machine you can checkout this repo:\nchezmoi init https://github.com/username/dotfiles.git  You can then see what would be changed:\nchezmoi diff  If you\u0026rsquo;re happy with the changes then apply them:\nchezmoi apply  The above commands can be combined into a single init, checkout, and apply:\nchezmoi init --apply --verbose https://github.com/username/dotfiles.git  Pull the latest changes from your repo and apply them You can pull the changes from your repo and apply them in a single command:\nchezmoi update  This runs git pull --rebase in your source directory and then chezmoi apply.\nPull the latest changes from your repo and see what would change, without actually applying the changes Run:\nchezmoi source pull -- --rebase \u0026amp;\u0026amp; chezmoi diff  This runs git pull --rebase in your source directory and chezmoi diff then shows the difference between the target state computed from your source directory and the actual state.\nIf you\u0026rsquo;re happy with the changes, then you can run\nchezmoi apply  to apply them.\nUse templates to manage files that vary from machine to machine The primary goal of chezmoi is to manage configuration files across multiple machines, for example your personal macOS laptop, your work Ubuntu desktop, and your work Linux laptop. You will want to keep much configuration the same across these, but also need machine-specific configurations for email addresses, credentials, etc. chezmoi achieves this functionality by using text/template for the source state where needed.\nFor example, your home ~/.gitconfig on your personal machine might look like:\n[user] email = \u0026quot;john@home.org\u0026quot;  Whereas at work it might be:\n[user] email = \u0026quot;john.smith@company.com\u0026quot;  To handle this, on each machine create a configuration file called ~/.config/chezmoi/chezmoi.toml defining what might change. For your home machine:\n[data] email = \u0026quot;john@home.org\u0026quot;  If you intend to store private data (e.g. access tokens) in ~/.config/chezmoi/chezmoi.toml, make sure it has permissions 0600.\nIf you prefer, you can use any format supported by Viper for your configuration file. This includes JSON, YAML, and TOML.\nThen, add ~/.gitconfig to chezmoi using the -T flag to automatically turn it in to a template:\nchezmoi add -T ~/.gitconfig  You can then open the template (which will be saved in the file ~/.local/share/chezmoi/dot_gitconfig.tmpl):\nchezmoi edit ~/.gitconfig  The file should look something like:\n[user] email = \u0026quot;{{ .email }}\u0026quot;  chezmoi will substitute the variables from the data section of your ~/.config/chezmoi/chezmoi.toml file when calculating the target state of .gitconfig.\nFor more advanced usage, you can use the full power of the text/template language to include or exclude sections of file. For a full list of variables, run:\nchezmoi data  For example, in your ~/.local/share/chezmoi/dot_bashrc.tmpl you might have:\n# common config export EDITOR=vi # machine-specific configuration {{- if eq .chezmoi.hostname \u0026quot;work-laptop\u0026quot; }} # this will only be included in ~/.bashrc on work-laptop {{- end }}  chezmoi includes all of the hermetic text functions from sprig.\nIf, after executing the template, the file contents are empty, the target file will be removed. This can be used to ensure that files are only present on certain machines. If you want an empty file to be created anyway, you will need to give it an empty_ prefix. See \u0026ldquo;Under the hood\u0026rdquo; below.\nFor coarser-grained control of files and entire directories are managed on different machines, or to exclude certain files completely, you can create .chezmoiignore files in the source directory. These specify a list of patterns that chezmoi should ignore, and are interpreted as templates. An example .chezmoiignore file might look like:\nREADME.md {{- if ne .chezmoi.hostname \u0026quot;work-laptop\u0026quot; }} .work # only manage .work on work-laptop {{- end }}  Patterns can be excluded by prefixing them with a !, for example:\nf* !foo  will ignore all files beginning with an f except foo.\nCreate a config file on a new machine automatically chezmoi init can also create a config file automatically, if one does not already exist. If your repo contains a file called .chezmoi.\u0026lt;format\u0026gt;.tmpl where format is one of the supported config file formats (e.g. json, toml, or yaml) then chezmoi init will execute that template to generate your initial config file.\nSpecifically, if you have .chezmoi.toml.tmpl that looks like this:\n{{- $email := promptString \u0026quot;email\u0026quot; -}} [data] email = \u0026quot;{{ $email }}\u0026quot;  Then chezmoi init will create an initial chezmoi.toml using this template. promptString is a special function that prompts the user (you) for a value.\nEnsure that a target is removed Create a file called .chezmoiremove in the source directory containing a list of patterns of files to remove. When you run\nchezmoi apply --remove  chezmoi will remove anything in the target directory that matches the pattern. As this command is potentially dangerous, you should run chezmoi in verbose, dry-run mode beforehand to see what would be removed:\nchezmoi apply --remove --dry-run --verbose  .chezmoiremove is interpreted as a template, so you can remove different files on different machines. Negative matches (patterns prefixed with a !) or targets listed in .chezmoiignore will never be removed.\nKeep data private chezmoi automatically detects when files and directories are private when adding them by inspecting their permissions. Private files and directories are stored in ~/.local/share/chezmoi as regular, public files with permissions 0644 and the name prefix private_. For example:\nchezmoi add ~/.netrc  will create ~/.local/share/chezmoi/private_dot_netrc (assuming ~/.netrc is not world- or group- readable, as it should be). This file is still private because ~/.local/share/chezmoi is not group- or world- readable or executable. chezmoi checks that the permissions of ~/.local/share/chezmoi are 0700 on every run and will print a warning if they are not.\nIt is common that you need to store access tokens in config files, e.g. a GitHub access token. There are several ways to keep these tokens secure, and to prevent them leaving your machine.\nUse Bitwarden to keep your secrets chezmoi includes support for Bitwarden using the Bitwarden CLI to expose data as a template function.\nLog in to Bitwarden using:\nbw login \u0026lt;bitwarden-email\u0026gt;  Unlock your Bitwarden vault:\nbw unlock  Set the BW_SESSION environment variable, as instructed.\nThe structured data from bw get is available as the bitwarden template function in your config files, for example:\nusername = {{ (bitwarden \u0026quot;item\u0026quot; \u0026quot;example.com\u0026quot;).login.username }} password = {{ (bitwarden \u0026quot;item\u0026quot; \u0026quot;example.com\u0026quot;).login.password }}  Use gopass to keep your secrets chezmoi includes support for gopass using the gopass CLI.\nThe first line of the output of gopass show \u0026lt;pass-name\u0026gt; is available as the gopass template function, for example:\n{{ gopass \u0026quot;\u0026lt;pass-name\u0026gt;\u0026quot; }}  Use gpg to keep your secrets chezmoi supports encrypting files with gpg. Encrypted files are stored in the source state and automatically be decrypted when generating the target state or printing a file\u0026rsquo;s contents with chezmoi cat. chezmoi edit will transparently decrypt the file before editing and re-encrypt it afterwards.\nAsymmetric (private/public-key) encryption Specify the encryption key to use in your configuration file (chezmoi.toml) with the gpg.recipient key:\n[gpg] recipient = \u0026quot;...\u0026quot;  Add files to be encrypted with the --encrypt flag, for example:\nchezmoi add --encrypt ~/.ssh/id_rsa  chezmoi will encrypt the file with:\ngpg --armor --recipient ${gpg.recipient} --encrypt  and store the encrypted file in the source state. The file will automatically be decrypted when generating the target state.\nSymmetric encryption Specify symmetric encryption in your configuration file:\n[gpg] symmetric = true  Add files to be encrypted with the --encrypt flag, for example:\nchezmoi add --encrypt ~/.ssh/id_rsa  chezmoi will encrypt the file with:\ngpg --armor --symmetric  Use KeePassXC to keep your secrets chezmoi includes support for KeePassXC using the KeePassXC CLI (keepassxc-cli) to expose data as a template function.\nProvide the path to your KeePassXC database in your configuration file:\n[keepassxc] database = \u0026quot;/home/user/Passwords.kdbx\u0026quot;  The structured data from keepassxc-cli show $database is available as the keepassxc template function in your config files, for example:\nusername = {{ (keepassxc \u0026quot;example.com\u0026quot;).UserName }} password = {{ (keepassxc \u0026quot;example.com\u0026quot;).Password }}  Additional attributes are available through the keepassxcAttribute function. For example, if you have an entry called SSH Key with an additional attribute called private-key, its value is available as:\n{{ keepassxcAttribute \u0026quot;SSH Key\u0026quot; \u0026quot;private-key\u0026quot; }}  Use a keyring to keep your secrets chezmoi includes support for Keychain (on macOS), GNOME Keyring (on Linux), and Windows Credentials Manager (on Windows) via the zalando/go-keyring library.\nSet passwords with:\n$ chezmoi keyring set --service=\u0026lt;service\u0026gt; --user=\u0026lt;user\u0026gt; Password: xxxxxxxx  The password can then be used in templates using the keyring function which takes the service and user as arguments.\nFor example, save a GitHub access token in keyring with:\n$ chezmoi keyring set --service=github --user=\u0026lt;github-username\u0026gt; Password: xxxxxxxx  and then include it in your ~/.gitconfig file with:\n[github] user = \u0026quot;{{ .github.user }}\u0026quot; token = \u0026quot;{{ keyring \u0026quot;github\u0026quot; .github.user }}\u0026quot;  You can query the keyring from the command line:\nchezmoi keyring get --service=github --user=\u0026lt;github-username\u0026gt;  Use LastPass to keep your secrets chezmoi includes support for LastPass using the LastPass CLI to expose data as a template function.\nLog in to LastPass using:\nlpass login \u0026lt;lastpass-username\u0026gt;  Check that lpass is working correctly by showing password data:\nlpass show --json \u0026lt;lastpass-entry-id\u0026gt;  where \u0026lt;lastpass-entry-id\u0026gt; is a LastPass Entry Specification.\nThe structured data from lpass show --json id is available as the lastpass template function. The value will be an array of objects. You can use the index function and .Field syntax of the text/template language to extract the field you want. For example, to extract the password field from first the \u0026ldquo;GitHub\u0026rdquo; entry, use:\ngithubPassword = \u0026quot;{{ (index (lastpass \u0026quot;GitHub\u0026quot;) 0).password }}\u0026quot;  chezmoi automatically parses the note value of the Lastpass entry, so, for example, you can extract a private SSH key like this:\n{{ (index (lastpass \u0026quot;SSH\u0026quot;) 0).note.privateKey }}  Keys in the note section written as CamelCase Words are converted to camelCaseWords.\nUse 1Password to keep your secrets chezmoi includes support for 1Password using the 1Password CLI to expose data as a template function.\nLog in and get a session using:\neval $(op signin \u0026lt;subdomain\u0026gt;.1password.com \u0026lt;email\u0026gt;)  The structured data from op get item \u0026lt;uuid\u0026gt; is available as the onepassword template function, for example:\n{{ (onepassword \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot;).details.password }}  Use pass to keep your secrets chezmoi includes support for pass using the pass CLI.\nThe first line of the output of pass show \u0026lt;pass-name\u0026gt; is available as the pass template function, for example:\n{{ pass \u0026quot;\u0026lt;pass-name\u0026gt;\u0026quot; }}  Use Vault to keep your secrets chezmoi includes support for Vault using the Vault CLI to expose data as a template function.\nThe vault CLI needs to be correctly configured on your machine, e.g. the VAULT_ADDR and VAULT_TOKEN environment variables must be set correctly. Verify that this is the case by running:\nvault kv get -format=json \u0026lt;key\u0026gt;  The stuctured data from vault kv get -format=json is available as the vault template function. You can use the .Field syntax of the text/template language to extract the data you want. For example:\n{{ (vault \u0026quot;\u0026lt;key\u0026gt;\u0026quot;).data.data.password }}  Use a generic tool to keep your secrets You can use any command line tool that outputs secrets either as a string or in JSON format. Choose the binary by setting genericSecret.command in your configuration file. You can then invoke this command with the secret and secretJSON template functions which return the raw output and JSON-decoded output respectively. All of the above secret managers can be supported in this way:\n   Secret Manager genericSecret.command Template skeleton     1Password op {{ secretJSON \u0026quot;get\u0026quot; \u0026quot;item\u0026quot; \u0026lt;id\u0026gt; }}   Bitwarden bw {{ secretJSON \u0026quot;get\u0026quot; \u0026lt;id\u0026gt; }}   Hashicorp Vault vault {{ secretJSON \u0026quot;kv\u0026quot; \u0026quot;get\u0026quot; \u0026quot;-format=json\u0026quot; \u0026lt;id\u0026gt; }}   LastPass lpass {{ secretJSON \u0026quot;show\u0026quot; \u0026quot;--json\u0026quot; \u0026lt;id\u0026gt; }}   KeePassXC keepassxc-cli Not possible (interactive command only)   pass pass {{ secret \u0026quot;show\u0026quot; \u0026lt;id\u0026gt; }}    Use templates variables to keep your secrets Typically, ~/.config/chezmoi/chezmoi.toml is not checked in to version control and has permissions 0600. You can store tokens as template values in the data section. For example, if your ~/.config/chezmoi/chezmoi.toml contains:\n[data] [data.github] user = \u0026quot;\u0026lt;github-username\u0026gt;\u0026quot; token = \u0026quot;\u0026lt;github-token\u0026gt;\u0026quot;  Your ~/.local/share/chezmoi/private_dot_gitconfig.tmpl can then contain:\n{{- if (index . \u0026quot;github\u0026quot;) }} [github] user = \u0026quot;{{ .github.user }}\u0026quot; token = \u0026quot;{{ .github.token }}\u0026quot; {{- end }}  Any config files containing tokens in plain text should be private (permissions 0600).\nUse scripts to perform actions Understand how scripts work chezmoi supports scripts, which are executed when you run chezmoi apply. The scripts can either run every time you run chezmoi apply, or only when their contents have changed.\nIn verbose mode, the script\u0026rsquo;s contents will be printed before executing it. In dry-run mode, the script is not executed.\nScripts are any file in the source directory with the prefix run_, and are executed in alphabetical order. Scripts that should only be run when their contents change have the prefix run_once_.\nScripts break chezmoi\u0026rsquo;s declarative approach, and as such should be used sparingly. Any script should be idempotent, even run_once_ scripts.\nScripts must be created manually in the source directory, typically by running chezmoi cd and then creating a file with a run_ prefix. Scripts are executed directly using exec and must include a shebang line or be executable binaries. There is no need to set the executable bit on the script.\nScripts with the suffix .tmpl are treated as templates, with the usual template variables available. If, after executing the template, the result is only whitespace or an empty string, then the script is not executed. This is useful for disabling scripts.\nInstall packages with scripts Change to the source directory and create a file called run_once_install-packages.sh:\nchezmoi cd $EDITOR run_once_install-packages.sh  In this file create your package installation script, e.g.\n#!/bin/sh sudo apt install ripgrep  The next time you run chezmoi apply or chezmoi update this script will be run. As it has the run_once_ prefix, it will not be run again unless its contents change, for example if you add more packages to be installed.\nThis script can also be a template. For example, if you create run_once_install-packages.sh.tmpl with the contents:\n{{ if eq .chezmoi.os \u0026quot;linux\u0026quot; -}} #!/bin/sh sudo apt install ripgrep {{ else if eq .chezmoi.os \u0026quot;darwin\u0026quot; -}} #!/bin/sh brew install ripgrep {{ end -}}  This will install ripgrep on both Debian/Ubuntu Linux systems and macOS.\nImport archives It is occasionally useful to import entire archives of configuration into your source state. The import command does this. For example, to import the latest version github.com/robbyrussell/oh-my-zsh to ~/.oh-my-zsh run:\ncurl -s -L -o oh-my-zsh-master.tar.gz https://github.com/robbyrussell/oh-my-zsh/archive/master.tar.gz chezmoi import --strip-components 1 --destination ~/.oh-my-zsh oh-my-zsh-master.tar.gz  Note that this only updates the source state. You will need to run\nchezmoi apply  to update your destination directory.\nExport archives chezmoi can create an archive containing the target state. This can be useful for generating target state on a different machine or for simply inspecting the target state. A particularly useful command is:\nchezmoi archive | tar tvf -  which lists all the targets in the target state.\nUse a non-git version control system By default, chezmoi uses git, but you can use any version control system of your choice. In your config file, specify the command to use. For example, to use Mercurial specify:\n[sourceVCS] command = \u0026quot;hg\u0026quot;  The source VCS command is used in the chezmoi commands init, source, and update, and support for VCSes other than git is limited but easy to add. If you\u0026rsquo;d like to see your VCS better supported, please open an issue on GitHub.\nUse a merge tool other than vimdiff By default, chezmoi uses vimdiff, but you can use any merge tool of your choice. In your config file, specify the command and args to use. For example, to use neovim\u0026rsquo;s diff mode specify:\n[merge] command = \u0026quot;nvim\u0026quot; args = \u0026quot;-d\u0026quot;  Migrate from a dotfile manager that uses symlinks Many dotfile managers replace dotfiles with symbolic links to files in a common directory. If you chezmoi add such a symlink, chezmoi will add the symlink, not the file. To assist with migrating from symlink-based systems, use the --follow / -f option to chezmoi add, for example:\nchezmoi add --follow ~/.bashrc  This will tell chezmoi add that the target state of ~/.bashrc is the target of the ~/.bashrc symlink, rather than the symlink itself. When you run chezmoi apply, chezmoi will replace the ~/.bashrc symlink with the file contents.\nExplore experimental features Automatically commit and push changes to your repo chezmoi includes an experimental feature to automatically commit and push changes to your source directory to your repo. This feature is disabled by default. To enable it, add the following to your config file:\n[sourceVCS] autoCommit = true autoPush = true  Whenever a change is made to your source directory, chezmoi will commit the changes with an automatically-generated commit message (if autoCommit is true) and push them to your repo (if autoPush is true). autoPush implies autoCommit, i.e. if autoPush is true then chezmoi will auto-commit your changes. If you only set autoCommit to true then changes will be commited but not pushed.\nautoCommit and autoPush are experimental features, likely to contain bugs (especially in corner cases) and will change in the future. If you encounter a problem or strange behavior, please open an issue.\n"});index.add({'id':7,'href':'/docs/install/','title':"Install",'content':" Install Guide  One-line binary install One-line package install Pre-built Linux packages Pre-built binaries From source Upgrading  One-line binary install Install the correct binary for your operating system and architecture in ./bin with a single command.\ncurl -sfL https://git.io/chezmoi | sh  One-line package install Install chezmoi with a single command.\n   OS Distribution Method Command     Linux - snap snap install chezmoi --classic   Linux Arch pacman pacman -S chezmoi   Linux - Linuxbrew brew install twpayne/taps/chezmoi   macOS - Homebrew brew install twpayne/taps/chezmoi   Windows - Scoop scoop bucket add twpayne https://github.com/twpayne/scoop-bucket \u0026amp;\u0026amp; scoop install chezmoi    Pre-built Linux packages Download a package for your operating system and architecture and install it with your package manager.\n   OS Architectures Package     Debian amd64, arm64, armel, i386, ppc64, ppc64le deb   RedHat aarch64, armhfp, i686, ppc64, ppc64le, x86_64 rpm   OpenSUSE aarch64, armhfp, i686, ppc64, ppc64le, x86_64 rpm   Ubuntu amd64, arm64, armel, i386, ppc64, ppc64le deb    Pre-built binaries Download a tarball for your operating system containing a pre-built binary, documentation, and shell completions.\n   OS Architectures Tarball     FreeBSD amd64, arm, i386 tar.gz   Linux amd64, arm, arm64, i386, ppc64, ppc64le tar.gz   macOS amd64 tar.gz   OpenBSD amd64, arm, i386 tar.gz    From source Download, build, and install chezmoi for your system:\ncd $(mktemp -d) \u0026amp;\u0026amp; go get -u github.com/twpayne/chezmoi  Upgrading Once chezmoi is installed, you can upgrade it to the latest release with:\nchezmoi upgrade  This will re-use whichever mechanism you used to install chezmoi to install the latest release.\n"});index.add({'id':8,'href':'/docs/quick-start/','title':"Quick Start",'content':" Quick Start Guide  Concepts Start using chezmoi on your current machine Using chezmoi across multiple machines Next steps  Concepts chezmoi stores the desired state of your dotfiles in the directory ~/.local/share/chezmoi. When you run chezmoi apply, chezmoi calculates the desired contents and permissions for each dotfile and then makes any changes necessary so that your dotfiles match that state.\nStart using chezmoi on your current machine Initialize chezmoi:\nchezmoi init  This will create a new git repository in ~/.local/share/chezmoi with permissions 0700 where chezmoi will store the source state. chezmoi only modifies files in the working copy. It is your responsibility to commit changes.\nManage an existing file with chezmoi:\nchezmoi add ~/.bashrc  This will copy ~/.bashrc to ~/.local/share/chezmoi/dot_bashrc.\nEdit the source state:\nchezmoi edit ~/.bashrc  This will open ~/.local/share/chezmoi/dot_bashrc in your $EDITOR. Make some changes and save them.\nSee what changes chezmoi would make:\nchezmoi diff  Apply the changes:\nchezmoi -v apply  All chezmoi commands accept the -v (verbose) flag to print out exactly what changes they will make to the file system, and the -n (dry run) flag to not make any actual changes. The combination -n -v is very useful if you want to see exactly what changes would be made.\nFinally, open a shell in the source directory, commit your changes, and return to where you were:\nchezmoi cd git add dot_bashrc git commit -m \u0026quot;Add .bashrc\u0026quot; exit  Using chezmoi across multiple machines Clone the git repo in ~/.local/share/chezmoi to a hosted Git service, e.g. GitHub, GitLab, or BitBucket. Many people call their dotfiles repo dotfiles. You can then set up chezmoi on a second machine:\nchezmoi init https://github.com/username/dotfiles.git  This will check out the repo and any submodules and optionally create a chezmoi config file for you. It won\u0026rsquo;t make any changes to your home directory until you run:\nchezmoi apply  On any machine, you can pull and apply the latest changes from your repo with:\nchezmoi update  Next steps For a full list of commands run:\nchezmoi help  chezmoi has much more functionality. Read the how-to guide to explore.\n"});index.add({'id':9,'href':'/docs/reference/','title':"Reference",'content':" Reference Manual Manage your dotfiles securely across multiple machines.\n Concepts Global command line flags  --color value -c, --config filename -D, --destination directory -f, --follow -n, --dry-run -h, --help -r. --remove -S, --source directory -v, --verbose --version  Configuration file  Configuration variables  Source state attributes Special files and directories  .chezmoi.\u0026lt;format\u0026gt;.tmpl .chezmoiignore .chezmoiremove .chezmoitemplates .chezmoiversion  Commands  add targets apply [targets] archive cat targets cd chattr attributes targets completion shell data diff [targets] docs [regexp] doctor dump [targets] edit [targets] edit-config forget targets help command init [repo] import filename merge targets remove targets secret source [args] source-path [targets] unmanaged update upgrade verify [targets]  Editor configuration Umask configuration Template variables Template functions  bitwarden [args] gopass gopass-name keepassxc entry keepassxcAttribute entry attribute keyring service user lastpass id onepassword uuid pass pass-name promptString prompt secret [args] secretJSON [args] vault key   Concepts chezmoi evaluates the source state for the current machine and then updates the destination directory, where:\n The source state declares the desired state of your home directory, including templates and machine-specific configuration.\n The source directory is where chezmoi stores the source state, by default ~/.local/share/chezmoi.\n The target state is the source state computed for the current machine.\n The destination directory is the directory that chezmoi manages, by default ~, your home directory.\n A target is a file, directory, or symlink in the destination directory.\n The destination state is the state of all the targets in the destination directory.\n The config file contains machine-specific configuration, by default it is ~/.config/chezmoi/chezmoi.toml.\n  Global command line flags Command line flags override any values set in the configuration file.\n--color value Colorize diffs, value can be on, off, or auto. The default value is auto which will colorize diffs only if the output is a terminal.\n-c, --config filename Read the configuration from filename.\n-D, --destination directory Use directory as the destination directory.\n-f, --follow If the last part of a target is a symlink, deal with what the symlink references, rather than the symlink itself.\n-n, --dry-run Set dry run mode. In dry run mode, the destination directory is never modified. This is most useful in combination with the -v (verbose) flag to print changes that would be made without making them.\n-h, --help Print help.\n-r. --remove Also remove targets according to .chezmoiremove.\n-S, --source directory Use directory as the source directory.\n-v, --verbose Set verbose mode. In verbose mode, chezmoi prints the changes that it is making as approximate shell commands, and any differences in files between the target state and the destination set are printed as unified diffs.\n--version Print the version of chezmoi, the commit at which it was built, and the build timestamp.\nConfiguration file chezmoi searches for its configuration file according to the XDG Base Directory Specification and supports all formats supported by github.com/spf13/viper, namely JSON, TOML, YAML, macOS property file format, and HCL. The basename of the config file is chezmoi, and the first config file found is used.\nConfiguration variables The following configuration variables are available:\n   Variable Type Default value Description     bitwarden.command string bw Bitwarden CLI command   color string auto Colorize diffs   data any none Template data   destDir string ~ Destination directory   dryRun bool false Dry run mode   follow bool false Follow symlinks   genericSecret.command string none Generic secret command   gopass.command string gopass gopass CLI command   gpg.recipient string none GPG recipient   gpg.symmetric bool false Use symmetric GPG encryption   keepassxc.args []string none Extra args to KeePassXC CLI command   keepassxc.command string keepassxc-cli KeePassXC CLI command   keepassxc.database string none KeePassXC database   lastpass.command string lpass Lastpass CLI command   merge.args []string none Extra args to 3-way merge command   merge.command string vimdiff 3-way merge command   onepassword.command string op 1Password CLI command   pass.command string pass Pass CLI command   remove bool false Remove targets   sourceDir string ~/.config/share/chezmoi Source directory   sourceVCS.autoCommit bool false Commit changes to the source state after any change   sourceVCS.autoPush bool false Push changes to the source state after any change   sourceVCS.command string git Source version control system   umask int from system Umask   vault.command string vault Vault CLI command   verbose bool false Verbose mode    In addition, a number of secret manager integrations add configuration variables. These are documented in the secret manager section.\nSource state attributes chezmoi stores the source state of files, symbolic links, and directories in regular files and directories in the source directory (~/.local/share/chezmoi by default). This location can be overridden with the -S flag or by giving a value for sourceDir in ~/.config/chezmoi/chezmoi.toml. Some state is encoded in the source names. chezmoi ignores all files and directories in the source directory that begin with a .. The following prefixes and suffixes are special, and are collectively referred to as \u0026ldquo;attributes\u0026rdquo;:\n   Prefix Effect     encrypted_ Encrypt the file in the source state.   once_ Only run script once.   private_ Remove all group and world permissions from the target file or directory.   empty_ Ensure the file exists, even if is empty. By default, empty files are removed.   exact_ Remove anything not managed by chezmoi.   executable_ Add executable permissions to the target file.   run_ Treat the contents as a script to run.   symlink_ Create a symlink instead of a regular file.   dot_ Rename to use a leading dot, e.g. dot_foo becomes .foo.       Suffix Effect     .tmpl Treat the contents of the source file as a template.    Order of prefixes is important, the order is run_, exact_, private_, empty_, executable_, symlink_, once_, dot_.\nDifferent target types allow different prefixes and suffixes:\n   Target type Allowed prefixes Allowed suffixes     Directory exact_, private_, dot_ none   Regular file encrypted_, private_, empty_, executable_, dot_ .tmpl   Script run_, once_ .tmpl   Symbolic link symlink_, dot_, .tmpl    Special files and directories All files and directories in the source state whose name begins with . are ignored by default, unless they are one of the special files listed here.\n.chezmoi.\u0026lt;format\u0026gt;.tmpl If a file called .chezmoi.\u0026lt;format\u0026gt;.tmpl exists then chezmoi init will use it to create an initial config file. format must be one of the the supported config file formats.\n.chezmoi.\u0026lt;format\u0026gt;.tmpl examples {{ $email := promptString \u0026quot;email\u0026quot; -}} data: email: \u0026quot;{{ $email }}\u0026quot;  .chezmoiignore If a file called .chezmoiignore exists in the source state then it is interpreted as a list of globs to ignore. Notably, .chezmoiignore is interpreted as a template. Patterns can be excluded by prefixing them with a !. All excludes (don\u0026rsquo;t ignore) take priority over all includes (ignore). .chezmoiignore files in subdirectories apply only to that subdirectory.\n.chezmoiignore is inspired by git\u0026rsquo;s .gitignore files, but is a separate implementation and corner case behaviour may differ.\n.chezmoiignore examples README.md {{- if ne .email \u0026quot;john.smith@company.com\u0026quot; }} .company-directory {{- end }} {{- if ne .email \u0026quot;john@home.org }} .personal-file {{- end }}  .chezmoiremove If a file called .chezmoiremove exists in the source state then it is interpreted as a list of targets to remove. .chezmoiremove is interpreted as a template.\n.chezmoitemplates If a directory called .chezmoitemplates exists, then all files in this directory are parsed as templates are available as templates with a name equal to the base name of the file. If more than one file has the same basename then the last one wins.\n.chezmoitemplates examples Given:\n.chezmoitemplates/foo {{ if true }}bar{{ end }} dot_config.tmpl {{ template \u0026quot;foo\u0026quot; }}  The target state of .config will be bar.\n.chezmoiversion If a file called .chezmoiversion exists, then its contents are interpreted as a semantic version defining the minimum version of chezmoi required to interpret the source state correctly. chezmoi will refuse to interpret the source state if the current version is too old.\nWarning support for .chezmoiversion will be introduced in a future version (likely 1.5.0). Earlier versions of chezmoi will ignore this file.\n.chezmoiversion examples 1.5.0  Commands add targets Add targets to the source state. If any target is already in the source state, then its source state is replaced with its current state in the destination directory. The add command accepts additional flags:\n-e, --empty Set the empty attribute on added files.\n-x, --exact Set the exact attribute on added directories.\n-p, --prompt Interactively prompt before adding each file.\n-r, --recursive Recursively add all files, directories, and symlinks.\n-T, --template Set the template attribute on added files and symlinks. In addition, if the --template-auto-generate flag is set, chezmoi attempts to automatically generate the template by replacing any template data values with the equivalent template data keys. Longer subsitutions occur before shorter ones.\nadd examples chezmoi add ~/.bashrc chezmoi add ~/.gitconfig --template chezmoi add ~/.vim --recursive chezmoi add ~/.oh-my-zsh --exact --recursive  apply [targets] Ensure that targets are in the target state, updating them if necessary. If no targets are specified, the state of all targets are ensured.\napply examples chezmoi apply chezmoi apply --dry-run --verbose chezmoi apply ~/.bashrc  archive Write a tar archive of the target state to stdout. This can be piped into tar to inspect the target state.\narchive examples chezmoi archive | tar tvf -  cat targets Write the target state of targets to stdout. targets must be files or symlinks. For files, the target file contents are written. For symlinks, the target target is written.\ncat examples chezmoi cat ~/.bashrc  cd Launch a shell in the source directory.\ncd examples chezmoi cd  chattr attributes targets Change the attributes of targets. attributes specifies which attributes to modify. Add attributes by specifying them or their abbreviations directly, optionally prefixed with a plus sign (+). Remove attributes by prefixing them or their attributes with the string no or a minus sign (-). The available attributes and their abbreviations are:\n   Attribute Abbreviation     empty e   encrypted none   exact none   executable x   private p   template t    Multiple attributes modifications may be specified by separating them with a comma (,).\nchattr examples chezmoi chattr template ~/.bashrc chezmoi chattr noempty ~/.profile chezmoi chattr private,template ~/.netrc  completion shell Output shell completion code for the specified shell (bash, fish, or zsh).\ncompletion examples chezmoi completion bash chezmoi completion fish \u0026gt; ~/.config/fish/completions/chezmoi chezmoi completion zsh  data Write the computed template data in JSON format to stdout. The data command accepts additional flags:\n-f, --format format Print the computed template data in the given format. The accepted formats are json (JSON), toml (TOML), and yaml (YAML).\ndata examples chezmoi data chezmoi data --format=yaml  diff [targets] Print the approximate shell commands required to ensure that targets in the destination directory match the target state. If no targets are specified, print the commands required for all targets. It is equivalent to chezmoi apply --dry-run --verbose.\ndiff examples chezmoi diff chezmoi diff ~/.bashrc  docs [regexp] Print the documentation page matching the regular expression regexp. Matching is case insensitive. If no pattern is given, print REFERENCE.md.\ndocs examples chezmoi docs chezmoi docs faq chezmoi docs howto  doctor Check for potential problems.\ndoctor examples chezmoi doctor  dump [targets] Dump the target state in JSON format. If no targets are specified, then the entire target state. The dump command accepts additional arguments:\n-f, --format format Print the target state in the given format. The accepted formats are json (JSON) and yaml (YAML).\ndump examples chezmoi dump ~/.bashrc chezmoi dump --format=yaml  edit [targets] Edit the source state of targets, which must be files or symlinks. If no targets are given the the source directory itself is opened with $EDITOR. The edit command accepts additional arguments:\n-a, --apply Apply target immediately after editing. Ignored if there are no targets.\n-d, --diff Print the difference between the target state and the actual state after editing.. Ignored if there are no targets.\n-p, --prompt Prompt before applying each target.. Ignored if there are no targets.\nedit examples chezmoi edit ~/.bashrc chezmoi edit ~/.bashrc --apply --prompt chezmoi edit  edit-config Edit the configuration file.\nedit-config examples chezmoi edit-config  forget targets Remove targets from the source state, i.e. stop managing them.\nforget examples chezmoi forget ~/.bashrc  help command Print the help associated with command.\ninit [repo] Setup the source directory and update the destination directory to match the target state. If repo is given then it is checked out into the source directory, otherwise a new repository is initialized in the source directory. If a file called .chezmoi.format.tmpl exists, where format is one of the supported file formats (e.g. json, toml, or yaml) then a new configuration file is created using that file as a template. Finally, if the --apply flag is passed, chezmoi apply is run.\ninit examples chezmoi init https://github.com/user/dotfiles.git chezmoi init https://github.com/user/dotfiles.git --apply  import filename Import the source state from an archive file in to a directory in the source state. This is primarily used to make subdirectories of your home directory exactly match the contents of a downloaded archive. You will generally always want to set the --destination, --exact, and --remove-destination flags.\nThe only supported archive format is .tar.gz.\n--destination directory Set the destination (in the source state) where the archive will be imported.\n-x, --exact Set the exact attribute on all imported directories.\n-r, --remove-destination Remove destination (in the source state) before importing.\n--strip-components n Strip n leading components from paths.\nimport examples curl -s -L -o oh-my-zsh-master.tar.gz https://github.com/robbyrussell/oh-my-zsh/archive/master.tar.gz chezmoi import --strip-components 1 --destination ~/.oh-my-zsh oh-my-zsh-master.tar.gz  merge targets Perform a three-way merge between the destination state, the source state, and the target state. The merge tool is defined by the merge.command configuration variable, and defaults to vimdiff. If multiple targets are specified the merge tool is invoked for each target. If the target state cannot be computed (for example if source is a template containing errors or an encrypted file that cannot be decrypted) a two-way merge is performed instead.\nmerge examples chezmoi merge ~/.bashrc  remove targets Remove targets from both the source state and the destination directory.\n-f, --force Remove without prompting.\nsecret Run a secret manager\u0026rsquo;s CLI, passing any extra arguments to the secret manager\u0026rsquo;s CLI. This is primarily for verifying chezmoi\u0026rsquo;s integration with your secret manager. Normally you would use template functions to retrieve secrets. Note that if you want to pass flags to the secret manager\u0026rsquo;s CLU you will need to separate them with -- to prevent chezmoi from interpreting them.\nTo get a full list of available commands run:\nchezmoi secret help  secret examples chezmoi secret bitwarden list items chezmoi secret keyring set --service service --user user chezmoi secret keyring get --service service --user user chezmoi secret lastpass ls chezmoi secret lastpass -- show --format=json id chezmoi secret onepassword list items chezmoi secret onepassword get item id chezmoi secret pass show id chezmoi secret vault -- kv get -format=json id  source [args] Execute the source version control system in the source directory with args. Note that any flags for the source version control system must be sepeated with a -- to stop chezmoi from reading them.\nsource examples chezmoi source init chezmoi source add . chezmoi source commit -- -m \u0026quot;Initial commit\u0026quot;  source-path [targets] Print the path to each target\u0026rsquo;s source state. If no targets are specified then print the source directory.\nsource-path examples chezmoi source-path chezmoi source-path ~/.bashrc  unmanaged List all unmanaged files in the destination directory.\nunmanaged examples chezmoi unmanaged  update Pull changes from the source VCS and apply any changes.\nupdate examples chezmoi update  upgrade Upgrade chezmoi by downloading and installing a new version. This will call the GitHub API to determine if there is a new version of chezmoi available, and if so, download and attempt to install it in the same way as chezmoi was previously installed.\nIf chezmoi was installed with a package manager (dpkg or rpm) then upgrade will download a new package and install it, using sudo if it is installed. Otherwise, chezmoi will download the latest executable and replace the existing executable with the new version.\nIf the CHEZMOI_GITHUB_API_TOKEN environment variable is set, then its value will be used to authenticate requests to the GitHub API, otherwise unauthenticated requests are used which are subject to stricter rate limiting. Unauthenticated requests should be sufficient for most cases.\nupgrade examples chezmoi upgrade  verify [targets] Verify that all targets match their target state. chezmoi exits with code 0 (success) if all targets match their target state, or 1 (failure) otherwise. If no targets are specified then all targets are checked.\nverify examples chezmoi verify chezmoi verify ~/.bashrc  Editor configuration The edit and edit-config commands use the editor specified by the VISUAL environment variable, the EDITOR environment variable, or vi, whichever is specified first.\nUmask configuration By default, chezmoi uses your current umask as set by your operating system and shell. chezmoi only stores crude permissions in its source state, namely in the executable and private attributes, corresponding to the umasks of 0111 and 0077 respectively.\nFor machine-specifc control of umask, set the umask configuration variable in chezmoi\u0026rsquo;s configuration file.\nTemplate variables chezmoi provides the following automatically populated variables:\n   Variable Value     .chezmoi.arch Architecture, e.g. amd64, arm, etc. as returned by runtime.GOARCH.   .chezmoi.fullHostname The full hostname of the machine chezmoi is running on.   .chezmoi.group The group of the user running chezmoi.   .chezmoi.homedir The home directory of the user running chezmoi.   .chezmoi.hostname The hostname of the machine chezmoi is running on, up to the first ..   .chezmoi.os Operating system, e.g. darwin, linux, etc. as returned by runtime.GOOS.   .chezmoi.osRelease The information from /etc/os-release, Linux only, run chezmoi data to see its output.   .chezmoi.username The username of the user running chezmoi.    Additional variables can be defined in the config file in the data section.\nTemplate functions All standard text/template and hermetic text template functions from sprig are included. chezmoi provides some additional functions.\nbitwarden [args] bitwarden returns structured data retrieved from Bitwarden using the Bitwarden CLI (bw). args are passed to bw unchanged and the output from bw is parsed as JSON. The output from bw is cached so calling bitwarden multitple times with the same arguments will only invoke bw once.\nbitwarden examples username = {{ (bitwarden \u0026quot;item\u0026quot; \u0026quot;example.com\u0026quot;).login.username }} password = {{ (bitwarden \u0026quot;item\u0026quot; \u0026quot;example.com\u0026quot;).login.password }}  gopass gopass-name gopass returns passwords stored in gopass using the gopass CLI (gopass). gopass-name is passed to gopass show \u0026lt;gopass-name\u0026gt; and first line of the output of gopass is returned with the trailing newline stripped. The output from gopass is cached so calling gopass multiple times with the same gopass-name will only invoke gopass once.\ngopass examples {{ gopass \u0026quot;\u0026lt;pass-name\u0026gt;\u0026quot; }}  keepassxc entry keepassxc returns structured data retrieved from a KeePassXC database using the KeePassXC CLI (keepassxc-cli). The database is configured by setting keepassxc.database in the configuration file. database and entry are passed to keepassxc-cli show. You will be prompted for the database password the first time keepassxc-cli is run, and the password is cached, in plain text, in memory until chezmoi terminates. The output from keepassxc-cli is parsed into key-value pairs and cached so calling keepassxc multiple times with the same entry will only invoke keepassxc-cli once.\nkeepassxc examples username = {{ (keepassxc \u0026quot;example.com\u0026quot;).UserName }} password = {{ (keepassxc \u0026quot;example.com\u0026quot;).Password }}  keepassxcAttribute entry attribute keepassxcAttribute returns the attribute attribute of entry using keepassxc-cli, with any leading or trailing whitespace removed. It behaves identically to the keepassxc function in terms of configuration, password prompting, password storage, and result caching.\nkeepassxcAttribute examples {{ keepassxcAttribute \u0026quot;SSH Key\u0026quot; \u0026quot;private-key\u0026quot; }}  keyring service user keyring retrieves the password associated with service and user from the user\u0026rsquo;s keyring.\n   OS Keyring     macOS Keychain   Linux GNOME Keyring    keyring examples [github] user = \u0026quot;{{ .github.user }}\u0026quot; token = \u0026quot;{{ keyring \u0026quot;github\u0026quot; .github.user }}\u0026quot;  lastpass id lastpass returns structured data from LastPass using the LastPass CLI (lpass). id is passed to lpass show --json \u0026lt;id\u0026gt; and the output from lpass is parsed as JSON. In addition, the note field, if present, is further parsed as JSON. The structured data is an array so typically the index function is used to extract the first item. The output from lpass is cached so calling lastpass multiple times with the same id will only invoke lpass once.\nlastpass examples githubPassword = \u0026quot;{{ (index (lastpass \u0026quot;GitHub\u0026quot;) 0).password }}\u0026quot; {{ (index (lastpass \u0026quot;SSH\u0026quot;) 0).note.privateKey }}  onepassword uuid onepassword returns structured data from 1Password using the 1Password CLI (op). uuid is passed to op get item \u0026lt;uuid\u0026gt; and the output from op is parsed as JSON. The output from op is cached so calling onepassword multiple times with the same uuid will only invoke op once.\nonepassword examples {{ (onepassword \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot;).details.password }}  pass pass-name pass returns passwords stored in pass using the pass CLI (pass). pass-name is passed to pass show \u0026lt;pass-name\u0026gt; and first line of the output of pass is returned with the trailing newline stripped. The output from pass is cached so calling pass multiple times with the same pass-name will only invoke pass once.\npass examples {{ pass \u0026quot;\u0026lt;pass-name\u0026gt;\u0026quot; }}  promptString prompt promptString takes a single argument is a string prompted to the user, and the return value is the user\u0026rsquo;s response to that prompt. It is only available when generating the initial conifig file.\npromptString examples {{ $email := promptString \u0026quot;email\u0026quot; -}} data: email: \u0026quot;{{ $email }}\u0026quot;  secret [args] secret returns the output of the generic secret command defined by the genericSecret.command configuration variable with args with leading and trailing whitespace removed. The output is cached so multitple calls to secret with the same args will only invoke the generic secret command once.\nsecretJSON [args] secretJSON returns structured data from the generic secret command defined by the genericSecret.command configuration variable with args. The output is parsed as JSON. The output is cached so multitple calls to secret with the same args will only invoke the generic secret command once.\nvault key vault returns structured data from Vault using the Vault CLI (vault). key is passed to vault kv get -format=json \u0026lt;key\u0026gt; and the output from vault is parsed as JSON. The output from vault is cached so calling vault multiple times with the same key will only invoke vault once.\nvault examples {{ (vault \u0026quot;\u0026lt;key\u0026gt;\u0026quot;).data.data.password }}  "});index.add({'id':10,'href':'/tags/','title':"Tags",'content':""});})();