'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/changes/','title':"Changes",'section':"Docs",'content':"Changes #  Upcoming #  Default diff format changing from chezmoi to git. #  Currently chezmoi outputs diffs in its own format, containing a mix of unified diffs and shell commands. This will be replaced with a git format diff in version 2.0.0.\ngpgRecipient config variable changing to gpg.recipient #  The gpgRecipient config variable is changing to gpg.recipient. To update, change your config from:\ngpgRecipient = \u0026quot;...\u0026quot;  to:\n[gpg] recipient = \u0026quot;...\u0026quot;  Support for the gpgRecipient config variable will be removed in version 2.0.0.\n"});index.add({'id':1,'href':'/docs/contributing/','title':"Contributing",'section':"Docs",'content':"Contributing Guide #  Getting started #  chezmoi is written in Go and development happens on GitHub. The rest of this document assumes that you\u0026rsquo;ve checked out chezmoi locally.\nDeveloping locally #  chezmoi requires Go 1.13 or later and Go modules enabled. Enable Go modules by setting the environment variable GO111MODULE=on.\nchezmoi is a standard Go project, using standard Go tooling, with a few extra tools. Ensure that these extra tools are installed with:\nmake ensure-tools  Build chezmoi:\ngo build .  Run all tests:\ngo test ./...  Run chezmoi:\ngo run .  Generated code #  chezmoi generates help text, shell completions, embedded files, and the website from a single source of truth. You must run\ngo generate  if you change includes any of the following:\n Modify any documentation in the docs/ directory. Modify any files in the assets/templates/ directory. Add or modify a command. Add or modify a command\u0026rsquo;s flags.  chezmoi\u0026rsquo;s continuous integration verifies that all generated files are up to date. Changes to generated files should be included in the commit that modifies the source of truth.\nContributing changes #  Bug reports, bug fixes, and documentation improvements are always welcome. Please open an issue or create a pull request with your report, fix, or improvement.\nIf you want to make a more significant change, please first open an issue to discuss the change that you want to make. Dave Cheney gives a good rationale as to why this is important.\nAll changes are made via pull requests. In your pull request, please make sure that:\n  All existing tests pass.\n  There are appropriate additional tests that demonstrate that your PR works as intended.\n  The documentation is updated, if necessary. For new features you should add an entry in docs/HOWTO.md and a complete description in docs/REFERENCE.md.\n  All generated files are up to date. You can ensure this by running go generate and including any modified files in your commit.\n  The code is correctly formatted, according to gofumports. You can ensure this by running make format.\n  The code passes golangci-lint. You can ensure this by running make lint.\n  The commit messages match chezmoi\u0026rsquo;s convention, specifically that they begin with a capitalized verb in the imperative and give a short description of what the commit does. Detailed information or justification can be optionally included in the body of the commit message.\n  Commits are logically separate, with no merge or \u0026ldquo;fixup\u0026rdquo; commits.\n  The branch applies cleanly to master.\n  Managing releases #  Releases are managed with goreleaser.\nTo build a test release, without publishing, (Linux only) run:\nmake test-release  To create a new release, create and push a tag, e.g.:\ngit tag v1.2.3 git push --tags  brew formula must be updated manually with the command:\nbrew bump-formula-pr --tag=v1.2.3 chezmoi  Packaging #  If you\u0026rsquo;re packaging chezmoi for an operating system or distribution:\n  Please set the version number, git commit, and build time in the binary. This greatly assists debugging when end users report problems or ask for help. You can do this by passing the following flags to the Go linker:\n-X main.version=$VERSION -X main.commit=$COMMIT -X main.date=$DATE -X main.builtBy=$BUILT_BY $VERSION should be the chezmoi version, e.g. 1.7.3. Any v prefix is optional and will be stripped, so you can pass the git tag in directly.\n$COMMIT should be the full git commit hash at which chezmoi is built, e.g. 4d678ce6850c9d81c7ab2fe0d8f20c1547688b91.\n$DATE should be the date of the build in RFC3339 format, e.g. 2019-11-23T18:29:25Z.\n$BUILT_BY should be a string indicating what mechanism was used to build the binary, e.g. goreleaser.\n  Please enable cgo, if possible. chezmoi can be built and run without cgo, but the .chezmoi.username and .chezmoi.group template variables may not be set correctly on some systems.\n  chezmoi includes a docs command which prints its documentation. By default, the docs are embedded in the binary. You can disable this behavior, and have chezmoi read its docs from the filesystem by building with the noembeddocs build tag and setting the directory where chezmoi can find them with the -X github.com/twpayne/chezmoi/cmd.DocDir=$DOCDIR linker flag. For example:\ngo build -tags noembeddocs -ldflags \u0026quot;-X github.com/twpayne/chezmoi/cmd.DocsDir=/usr/share/doc/chezmoi\u0026quot; . To remove the docs command completely, use the nodocs build tag.\n  chezmoi includes an upgrade command which attempts to self-upgrade. You can remove this command completely by building chezmoi with the noupgrade build tag.\n  chezmoi includes shell completions in the completions directory. Please include these in the package and install them in the shell-appropriate directory, if possible.\n  If the instructions for installing chezmoi in chezmoi\u0026rsquo;s install guide are absent or incorrect, please open an issue or submit a PR to correct them.\n  Updating the website #  The website is generated with Hugo and served with GitHub pages from the gh-pages branch to GitHub.\nBefore building the website, you must download the Hugo Book Theme by running:\ngit submodule update --init  Test the website locally by running:\n( cd chezmoi.io \u0026amp;\u0026amp; hugo serve )  and visit http://localhost:1313/.\nTo build the website in a temporary directory, run:\n( cd chezmoi.io \u0026amp;\u0026amp; make )  From here you can run\ngit show  to show changes and\ngit push  to push them. You can only push changes if you have write permissions to the chezmoi GitHub repo.\n"});index.add({'id':3,'href':'/docs/faq/','title':"FAQ",'section':"Docs",'content':"Frequently Asked Questions #  How can I quickly check for problems with chezmoi on my machine? #  Run:\nchezmoi doctor  Anything ok is fine, anything warning is only a problem if you want to use the related feature, and anything error indicates a definite problem.\nWhat are the consequences of \u0026ldquo;bare\u0026rdquo; modifications to the target files? If my .zshrc is managed by chezmoi and I edit ~/.zshrc without using chezmoi edit, what happens? #  chezmoi will overwrite the file the next time you run chezmoi apply. Until you run chezmoi apply your modified ~/.zshrc will remain in place.\nHow can I tell what dotfiles in my home directory aren\u0026rsquo;t managed by chezmoi? Is there an easy way to have chezmoi manage a subset of them? #  chezmoi unmanaged will list everything not managed by chezmoi. You can add entire directories with chezmoi add -r.\nHow can I tell what dotfiles in my home directory are currently managed by chezmoi? #  chezmoi managed will list everything managed by chezmoi.\nIf there\u0026rsquo;s a mechanism in place for the above, is there also a way to tell chezmoi to ignore specific files or groups of files (e.g. by directory name or by glob)? #  By default, chezmoi ignores everything that you haven\u0026rsquo;t explicitly chezmoi add\u0026lsquo;ed. If you have files in your source directory that you don\u0026rsquo;t want added to your destination directory when you run chezmoi apply add their names to a file called .chezmoiignore in the source state.\nPatterns are supported, and you can change what\u0026rsquo;s ignored from machine to machine. The full usage and syntax is described in the reference manual.\nIf the target already exists, but is \u0026ldquo;behind\u0026rdquo; the source, can chezmoi be configured to preserve the target version before replacing it with one derived from the source? #  Yes. Run chezmoi add will update the source state with the target. To see diffs of what would change, without actually changing anything, use chezmoi diff.\nOnce I\u0026rsquo;ve made a change to the source directory, how do I commit it? #  You have several options:\n chezmoi cd opens a shell in the source directory, where you can run your usual version control commands, like git add and git commit. chezmoi git and chezmoi hg run git and hg respectively in the source directory and pass extra arguments to the command. If you\u0026rsquo;re passing any flags, you\u0026rsquo;ll need to use -- to prevent chezmoi from consuming them, for example chezmoi git -- commit -m \u0026quot;Update dotfiles\u0026quot;. chezmoi source runs your configured version control system in your source directory. It works in the same way as the chezmoi git and chezmoi hg commands, but uses sourceVCS.command.  How do I only run a script when a file has changed? #  A common example of this is that you\u0026rsquo;re using Homebrew and have .Brewfile listing all the packages that you want installed and only want to run brew bundle --global when the contents of .Brewfile have changed.\nchezmoi has two types of scripts: scripts that run every time, and scripts that only run when their contents change. chezmoi does not have a mechanism to run a script when an arbitrary file has changed, but there are some ways to achieve the desired behavior:\n  Have the script create .Brewfile instead of chezmoi, e.g. in your run_once_install-packages:\n#!/bin/sh  cat \u0026gt; $HOME/.Brewfile \u0026lt;\u0026lt;EOF brew \u0026#34;imagemagick\u0026#34; brew \u0026#34;openssl\u0026#34; EOF brew bundle --global   Don\u0026rsquo;t use .Brewfile, and instead install the packages explicitly in run_once_install-packages:\n#!/bin/sh  brew install imagemagick || true brew install openssl || true The || true is necessary because brew install exits with failure if the package is already installed.\n  Use a script that runs every time (not just once) and rely on brew bundle --global being idempotent.\n  Use a script that runs every time, records a checksum of .Brewfile in another file, and only runs brew bundle --global if the checksum has changed, and updates the recorded checksum after.\n  I\u0026rsquo;ve made changes to both the destination state and the source state that I want to keep. How can I keep them both? #  chezmoi merge will open a merge tool to resolve differences between the source state, target state, and destination state. Copy the changes you want to keep in to the source state.\nWhy does chezmoi convert all my template variables to lowercase? #  This is due to a feature in github.com/spf13/viper, the library that chezmoi uses to read its configuration file. For more information see this GitHub issue.\nchezmoi makes ~/.ssh/config group writeable. How do I stop this? #  By default, chezmoi uses your system\u0026rsquo;s umask when creating files. On most systems the default umask is 0022 but some systems use 0002, which means that files and directories are group writeable by default.\nYou can override this for chezmoi by setting the umask configuration variable in your configuration file, for example:\numask = 0022  Note that this will apply to all files and directories that chezmoi manages and will ensure that none of them are group writeable. It is not currently possible to control group write permissions for individual files or directories. Please open an issue on GitHub if you need this.\nCan I change how chezmoi\u0026rsquo;s source state is represented on disk? #  There are a number of criticisms of how chezmoi\u0026rsquo;s source state is represented on disk:\n The source file naming system cannot handle all possible filenames. Not all possible file permissions can be represented. The long source file names are verbose. Everything is in a single directory, which can end up containing many entries.  chezmoi\u0026rsquo;s source state representation is a deliberate, practical compromise.\nCertain target filenames, for example ~/dot_example, are incompatible with chezmoi\u0026rsquo;s attributes used in the source state. In practice, dotfile filenames are unlikely to conflict with chezmoi\u0026rsquo;s attributes. If this does cause a genuine problem for you, please open an issue on GitHub.\nThe dot_ attribute makes it transparent which dotfiles are managed by chezmoi and which files are ignored by chezmoi. chezmoi ignores all files and directories that start with . so no special whitelists are needed for version control systems and their control files (e.g. .git and .gitignore).\nchezmoi needs per-file metadata to know how to interpret the source file\u0026rsquo;s contents, for example to know when the source file is a template or if the file\u0026rsquo;s contents are encrypted. By storing this metadata in the filename, the metadata is unambiguously associated with a single file and adding, updating, or removing a single file touches only a single file in the source state. Changes to the metadata (e.g. chezmoi chattr +template *target*) are simple file renames and isolated to the affected file.\nIf chezmoi were to, say, use a common configuration file listing which files were templates and/or encrypted, then changes to any file would require updates to the common configuration file. Automating updates to configuration files requires a round trip (read config file, update config, write config) and it is not always possible preserve comments and formatting.\nchezmoi\u0026rsquo;s attributes of executable_ and private_ only allow a the file permissions 0o644, 0o755, 0o600, and 0o700 to be represented. Directories can only have permissions 0o755 or 0o700. In practice, these cover all permissions typically used for dotfiles. If this does cause a genuine problem for you, please open an issue on GitHub.\nFile permissions and modes like executable_, private_, and symlink_ could also be stored in the filesystem, rather than in the filename. However, this requires the permissions to be preserved and handled by the underlying version control system and filesystem. chezmoi provides first-class support for Windows, where the executable_ and private_ attributes have no direct equivalents and symbolic links are not always permitted. Some version control systems do not preserve file permissions or handle symbolic links. By using regular files and directories, chezmoi avoids variations in the operating system, version control system, and filesystem making it both more robust and more portable.\nchezmoi uses a 1:1 mapping between entries in the source state and entries in the target state. This mapping is bi-directional and unambiguous.\nHowever, this also means that dotfiles that in the same directory in the target state must be in the same directory in the source state. In particular, every entry managed by chezmoi in the root of your home directory has a corresponding entry in the root of your source directory, which can mean that you end up with a lot of entries in the root of your source directory.\nIf chezmoi were to permit, say, multiple separate source directories (so you could, say, put dot_bashrc in a bash/ subdirectory, and dot_vimrc in a vim/ subdirectory, but have chezmoi apply map these to ~/.bashrc and ~/.vimrc in the root of your home directory) then the mapping between source and target states is no longer bidirectional nor unambiguous, which significantly increases complexity and requires more user interaction. For example, if both bash/dot_bashrc and vim/dot_bashrc exist, what should be the contents of ~/.bashrc? If you run chezmoi add ~/.zshrc, should dot_zshrc be stored in the source bash/ directory, the source vim/ directory, or somewhere else? How does the user communicate their preferences?\nchezmoi has many users and any changes to the source state representation must be backwards-compatible.\nIn summary, chezmoi\u0026rsquo;s source state representation is a compromise with both advantages and disadvantages. Changes to the representation will be considered, but must meet the following criteria, in order of importance:\n Be fully backwards-compatible for existing users. Fix a genuine problem encountered in practice. Be independent of the underlying operating system, version control system, and filesystem. Not add significant extra complexity to the user interface or underlying implementation.  gpg encryption fails. What could be wrong? #  The gpg.recipient key should be ultimately trusted, otherwise encryption will fail because gpg will prompt for input, which chezmoi does not handle. You can check the trust level by running:\ngpg --export-ownertrust  The trust level for the recipient\u0026rsquo;s key should be 6. If it is not, you can change the trust level by running:\ngpg --edit-key $recipient  Enter trust at the prompt and chose 5 = I trust ultimately.\nI\u0026rsquo;m getting errors trying to build chezmoi from source #  chezmoi requires Go version 1.13 or later and Go modules enabled. You can check the version of Go with:\ngo version  Enable Go modules by setting GO111MODULE=on when running go get:\nGO111MODULE=on go get -u github.com/twpayne/chezmoi  For more details on building chezmoi, see the Contributing Guide.\nWhat inspired chezmoi? #  chezmoi was inspired by Puppet, but created because Puppet is a slow overkill for managing your personal configuration files. The focus of chezmoi will always be personal home directory management. If your needs grow beyond that, switch to a whole system configuration management tool.\nWhy not use Ansible/Chef/Puppet/Salt, or similar to manage my dotfiles instead? #  Whole system management tools are more than capable of managing your dotfiles, but are large systems that entail several disadvantages. Compared to whole system management tools, chezmoi offers:\n Small, focused feature set designed for dotfiles. There\u0026rsquo;s simply less to learn with chezmoi compared to whole system management tools. Easy installation and execution on every platform, without root access. Installing chezmoi requires only copying a single binary file with no external dependencies. Executing chezmoi just involves running the binary. In contrast, installing and running a whole system management tools typically requires installing a scripting language runtime, several packages, and running a system service, all typically requiring root access.  chezmoi\u0026rsquo;s focus and simple installation means that it runs almost everywhere: from tiny ARM-based Linux systems to Windows desktops, from inside lightweight containers to FreeBSD-based virtual machines in the cloud.\nCan I use chezmoi to manage files outside my home directory? #  In practice, yes, you can, but this is strongly discouraged beyond using your system\u0026rsquo;s package manager to install the packages you need.\nchezmoi is designed to operate on your home directory, and is explicitly not a full system configuration management tool. That said, there are some ways to have chezmoi manage a few files outside your home directory.\nchezmoi\u0026rsquo;s scripts can execute arbitrary commands, so you can use a run_ script that is run every time you run chezmoi apply, to, for example:\n Make the target file outside your home directory a symlink to a file managed by chezmoi in your home directory. Copy a file managed by chezmoi inside your home directory to the target file. Execute a template with chezmoi execute-template --output=filename template where filename is outside the target directory.  chezmoi executes all scripts as the user executing chezmoi, so you may need to add extra privilege elevation commands like sudo or PowerShell start -verb runas -wait to your script.\nchezmoi, by default, operates on your home directory but this can be overridden with the --destination command line flag or by specifying destDir in your config file, and could even be the root directory (/ or C:\\). This allows you, in theory, to use chezmoi to manage any file in your filesystem, but this usage is extremely strongly discouraged.\nIf your needs extend beyond modifying a handful of files outside your target system, then existing configuration management tools like Puppet, Chef, Ansible, and Salt are much better suited - and of course can be called from a chezmoi run_ script. Put your Puppet Manifests, Chef Recipes, Ansible Modules, and Salt Modules in a directory ignored by .chezmoiignore so they do not pollute your home directory.\nWhere does the name \u0026ldquo;chezmoi\u0026rdquo; come from? #  \u0026ldquo;chezmoi\u0026rdquo; splits to \u0026ldquo;chez moi\u0026rdquo; and pronounced /ʃeɪ mwa/ (shay-moi) meaning \u0026ldquo;at my house\u0026rdquo; in French. It\u0026rsquo;s seven letters long, which is an appropriate length for a command that is only run occasionally.\nWhat other questions have been asked about chezmoi? #  See the issues on GitHub.\nWhere do I ask a question that isn\u0026rsquo;t answered here? #  Please open an issue on GitHub.\nI like chezmoi. How do I say thanks? #  Thank you! chezmoi was written to scratch a personal itch, and I\u0026rsquo;m very happy that it\u0026rsquo;s useful to you. Please give chezmoi a star on GitHub, and if you\u0026rsquo;re happy to share your public dotfile repo then tag it with chezmoi. Contributions are very welcome and every bug report, support request, and feature request helps make chezmoi better. Thank you :)\n"});index.add({'id':4,'href':'/docs/how-to/','title':"How-To",'section':"Docs",'content':"How-To Guide #  Use a hosted repo to manage your dotfiles across multiple machines #  chezmoi relies on your version control system and hosted repo to share changes across multiple machines. You should create a repo on the source code repository of your choice (e.g. Bitbucket, GitHub, or GitLab, many people call their repo dotfiles) and push the repo in the source directory here. For example:\nchezmoi cd git remote add origin https://github.com/username/dotfiles.git git push -u origin master exit  On another machine you can checkout this repo:\nchezmoi init https://github.com/username/dotfiles.git  You can then see what would be changed:\nchezmoi diff  If you\u0026rsquo;re happy with the changes then apply them:\nchezmoi apply  The above commands can be combined into a single init, checkout, and apply:\nchezmoi init --apply --verbose https://github.com/username/dotfiles.git  Pull the latest changes from your repo and apply them #  You can pull the changes from your repo and apply them in a single command:\nchezmoi update  This runs git pull --rebase in your source directory and then chezmoi apply.\nPull the latest changes from your repo and see what would change, without actually applying the changes #  Run:\nchezmoi source pull -- --rebase \u0026amp;\u0026amp; chezmoi diff  This runs git pull --rebase in your source directory and chezmoi diff then shows the difference between the target state computed from your source directory and the actual state.\nIf you\u0026rsquo;re happy with the changes, then you can run\nchezmoi apply  to apply them.\nAutomatically commit and push changes to your repo #  chezmoi can automatically commit and push changes to your source directory to your repo. This feature is disabled by default. To enable it, add the following to your config file:\n[sourceVCS] autoCommit = true autoPush = true  Whenever a change is made to your source directory, chezmoi will commit the changes with an automatically-generated commit message (if autoCommit is true) and push them to your repo (if autoPush is true). autoPush implies autoCommit, i.e. if autoPush is true then chezmoi will auto-commit your changes. If you only set autoCommit to true then changes will be committed but not pushed.\nBe careful when using autoPush. If your dotfiles repo is public and you accidentally add a secret in plain text, that secret will be pushed to your public repo.\nUse templates to manage files that vary from machine to machine #  The primary goal of chezmoi is to manage configuration files across multiple machines, for example your personal macOS laptop, your work Ubuntu desktop, and your work Linux laptop. You will want to keep much configuration the same across these, but also need machine-specific configurations for email addresses, credentials, etc. chezmoi achieves this functionality by using text/template for the source state where needed.\nFor example, your home ~/.gitconfig on your personal machine might look like:\n[user] email = \u0026quot;john@home.org\u0026quot;  Whereas at work it might be:\n[user] email = \u0026quot;john.smith@company.com\u0026quot;  To handle this, on each machine create a configuration file called ~/.config/chezmoi/chezmoi.toml defining variables that might vary from machine to machine. For example, for your home machine:\n[data] email = \u0026quot;john@home.org\u0026quot;  Note that all variable names will be converted to lowercase. This is due to a feature of a library used by chezmoi.\nIf you intend to store private data (e.g. access tokens) in ~/.config/chezmoi/chezmoi.toml, make sure it has permissions 0600.\nIf you prefer, you can use any format supported by Viper for your configuration file. This includes JSON, YAML, and TOML. Variable names must start with a letter and be followed by zero or more letters or digits.\nThen, add ~/.gitconfig to chezmoi using the --autotemplate flag to turn it into a template and automatically detect variables from the data section of your ~/.config/chezmoi/chezmoi.toml file:\nchezmoi add --autotemplate ~/.gitconfig  You can then open the template (which will be saved in the file ~/.local/share/chezmoi/dot_gitconfig.tmpl):\nchezmoi edit ~/.gitconfig  The file should look something like:\n[user] email = \u0026quot;{{ .email }}\u0026quot;  To disable automatic variable detection, use the --template or -T option to chezmoi add instead of --autotemplate.\nTemplates are often used to capture machine-specific differences. For example, in your ~/.local/share/chezmoi/dot_bashrc.tmpl you might have:\n# common config export EDITOR=vi # machine-specific configuration {{- if eq .chezmoi.hostname \u0026quot;work-laptop\u0026quot; }} # this will only be included in ~/.bashrc on work-laptop {{- end }}  For a full list of variables, run:\nchezmoi data  For more advanced usage, you can use the full power of the text/template language. chezmoi includes all of the text functions from sprig and its own functions for interacting with password managers.\nTemplates can be executed directly from the command line, without the need to create a file on disk, with the execute-template command, for example:\nchezmoi execute-template '{{ .chezmoi.os }}/{{ .chezmoi.arch }}'  This is useful when developing or debugging templates.\nSome password managers allow you to store complete files. The files can be retrieved with chezmoi\u0026rsquo;s template functions. For example, if you have a file stored in 1Password with the UUID uuid then you can retrieve it with the template:\n{{- onepasswordDocument \u0026quot;uuid\u0026quot; -}}  The -s inside the brackets remove any whitespace before or after the template expression, which is useful if your editor has added any newlines.\nIf, after executing the template, the file contents are empty, the target file will be removed. This can be used to ensure that files are only present on certain machines. If you want an empty file to be created anyway, you will need to give it an empty_ prefix.\nFor coarser-grained control of files and entire directories managed on different machines, or to exclude certain files completely, you can create .chezmoiignore files in the source directory. These specify a list of patterns that chezmoi should ignore, and are interpreted as templates. An example .chezmoiignore file might look like:\nREADME.md {{- if ne .chezmoi.hostname \u0026quot;work-laptop\u0026quot; }} .work # only manage .work on work-laptop {{- end }}  The use of ne (not equal) is deliberate. What we want to achieve is \u0026ldquo;only install .work if hostname is work-laptop\u0026rdquo; but chezmoi installs everything by default, so we have to turn the logic around and instead write \u0026ldquo;ignore .work unless the hostname is work-laptop\u0026rdquo;.\nPatterns can be excluded by prefixing them with a !, for example:\nf* !foo  will ignore all files beginning with an f except foo.\nUse completely separate config files on different machines #  chezmoi\u0026rsquo;s template functionality allows you to change a file\u0026rsquo;s contents based on any variable. For example, if you want ~/.bashrc to be different on Linux and macOS you would create a file in the source state called dot_bashrc.tmpl containing:\n{{ if eq .chezmoi.os \u0026quot;darwin\u0026quot; -}} # macOS .bashrc contents {{ else if eq .chezmoi.os \u0026quot;linux\u0026quot; -}} # Linux .bashrc contents {{ end -}} However, if the differences between the two versions are so large that you\u0026rsquo;d prefer to use completely separate files in the source state, you can achieve this using a symbolic link template. Create the following files:\nsymlink_dot_bashrc.tmpl:\n.bashrc_{{ .chezmoi.os }} dot_bashrc_darwin:\n# macOS .bashrc contents dot_bashrc_linux:\n# Linux .bashrc contents .chezmoiignore\n{{ if ne .chezmoi.os \u0026quot;darwin\u0026quot; }} .bashrc_darwin {{ end }} {{ if ne .chezmoi.os \u0026quot;linux\u0026quot; }} .bashrc_linux {{ end }} This will make ~/.bashrc will be a symlink to .bashrc_darwin on darwin and to .bashrc_linux. The .chezmoiignore configuration ensures that only the OS-specific .bashrc_os file will be installed on each OS.\nCreate a config file on a new machine automatically #  chezmoi init can also create a config file automatically, if one does not already exist. If your repo contains a file called .chezmoi.\u0026lt;format\u0026gt;.tmpl where format is one of the supported config file formats (e.g. json, toml, or yaml) then chezmoi init will execute that template to generate your initial config file.\nSpecifically, if you have .chezmoi.toml.tmpl that looks like this:\n{{- $email := promptString \u0026quot;email\u0026quot; -}} [data] email = \u0026quot;{{ $email }}\u0026quot;  Then chezmoi init will create an initial chezmoi.toml using this template. promptString is a special function that prompts the user (you) for a value.\nTo test this template, use chezmoi execute-template with the --init and --promptString flags, for example:\nchezmoi execute-template --init --promptString email=john@home.org \u0026lt; ~/.local/share/chezmoi/.chezmoi.toml.tmpl  Have chezmoi create a directory, but ignore its contents #  If you want chezmoi to create a directory, but ignore its contents, say ~/src, first run:\nmkdir -p $(chezmoi source-path)/src  This creates the directory in the source state, which means that chezmoi will create it (if it does not already exist) when you run chezmoi apply.\nHowever, as this is an empty directory it will be ignored by git. So, create a file in the directory in the source state that will be seen by git (so git does not ignore the directory) but ignored by chezmoi (so chezmoi does not include it in the target state):\ntouch $(chezmoi source-path)/src/.keep  chezmoi automatically creates .keep files when you add an empty directory with chezmoi add.\nEnsure that a target is removed #  Create a file called .chezmoiremove in the source directory containing a list of patterns of files to remove. When you run\nchezmoi apply --remove  chezmoi will remove anything in the target directory that matches the pattern. As this command is potentially dangerous, you should run chezmoi in verbose, dry-run mode beforehand to see what would be removed:\nchezmoi apply --remove --dry-run --verbose  .chezmoiremove is interpreted as a template, so you can remove different files on different machines. Negative matches (patterns prefixed with a !) or targets listed in .chezmoiignore will never be removed.\nInclude a subdirectory from another repository, like Oh My Zsh #  To include a subdirectory from another repository, e.g. Oh My Zsh, you cannot use git submodules because chezmoi uses its own format for the source state and Oh My Zsh is not distributed in this format. Instead, you can use the import command to import a snapshot from a tarball:\ncurl -s -L -o oh-my-zsh-master.tar.gz https://github.com/robbyrussell/oh-my-zsh/archive/master.tar.gz chezmoi import --strip-components 1 --destination ${HOME}/.oh-my-zsh oh-my-zsh-master.tar.gz  Add oh-my-zsh-master.tar.gz to .chezmoiignore if you run these commands in your source directory so that chezmoi doesn\u0026rsquo;t try to copy the tarball anywhere.\nDisable Oh My Zsh auto-updates by setting DISABLE_AUTO_UPDATE=\u0026quot;true\u0026quot; in ~/.zshrc. Auto updates will cause the ~/.oh-my-zsh directory to drift out of sync with chezmoi\u0026rsquo;s source state. To update Oh My Zsh, re-run the curl and chezmoi import commands above.\nHandle configuration files which are externally modified #  Some programs modify their configuration files. When you next run chezmoi apply, any modifications made by the program will be lost.\nYou can track changes to these files by replacing with a symlink back to a file in your source directory, which is under version control. Here is a worked example for VSCode\u0026rsquo;s settings.json on Linux:\nCopy the configuration file to your source directory:\ncp ~/.config/Code/User/settings.json $(chezmoi source-path)  Tell chezmoi to ignore this file:\necho settings.json \u0026gt;\u0026gt; $(chezmoi source-path)/.chezmoiignore  Tell chezmoi that ~/.config/Code/User/settings.json should be a symlink to the file in your source directory:\nmkdir -p $(chezmoi source-path)/private_dot_config/private_Code/User echo -n \u0026quot;{{ .chezmoi.sourceDir }}/settings.json\u0026quot; \u0026gt; $(chezmoi source-path)/private_dot_config/private_Code/User/symlink_settings.json.tmpl  The prefix private_ is used because the ~/.config and ~/.config/Code directories are private by default.\nApply the changes:\nchezmoi apply -v  Now, when the program modifies its configuration file it will modify the file in the source state instead.\nHandle different file locations on different systems with the same contents #  If you want to have the same file contents in different locations on different systems, but maintain only a single file in your source state, you can use a shared template.\nCreate the common file in the .chezmoitemplates directory in the source state. For example, create .chezmoitemplates/file.conf. The contents of this file are available in templates with the template *name* function where name is the name of the file.\nThen create files for each system, for example Library/Application Support/App/file.conf.tmpl for macOS and dot_config/app/file.conf.tmpl for Linux. Both template files should contain {{- template \u0026quot;file.conf\u0026quot; -}}.\nFinally, tell chezmoi to ignore files where they are not needed by adding lines to your .chezmoiignore file, for example:\n{{ if ne .chezmoi.os \u0026quot;darwin\u0026quot; }} Library/Application Support/App/file.conf {{ end }} {{ if ne .chezmoi.os \u0026quot;linux\u0026quot; }} .config/app/file.conf {{ end }} Keep data private #  chezmoi automatically detects when files and directories are private when adding them by inspecting their permissions. Private files and directories are stored in ~/.local/share/chezmoi as regular, public files with permissions 0644 and the name prefix private_. For example:\nchezmoi add ~/.netrc  will create ~/.local/share/chezmoi/private_dot_netrc (assuming ~/.netrc is not world- or group- readable, as it should be). This file is still private because ~/.local/share/chezmoi is not group- or world- readable or executable. chezmoi checks that the permissions of ~/.local/share/chezmoi are 0700 on every run and will print a warning if they are not.\nIt is common that you need to store access tokens in config files, e.g. a GitHub access token. There are several ways to keep these tokens secure, and to prevent them leaving your machine.\nUse Bitwarden to keep your secrets #  chezmoi includes support for Bitwarden using the Bitwarden CLI to expose data as a template function.\nLog in to Bitwarden using:\nbw login \u0026lt;bitwarden-email\u0026gt;  Unlock your Bitwarden vault:\nbw unlock  Set the BW_SESSION environment variable, as instructed.\nThe structured data from bw get is available as the bitwarden template function in your config files, for example:\nusername = {{ (bitwarden \u0026quot;item\u0026quot; \u0026quot;example.com\u0026quot;).login.username }} password = {{ (bitwarden \u0026quot;item\u0026quot; \u0026quot;example.com\u0026quot;).login.password }}  Use gopass to keep your secrets #  chezmoi includes support for gopass using the gopass CLI.\nThe first line of the output of gopass show \u0026lt;pass-name\u0026gt; is available as the gopass template function, for example:\n{{ gopass \u0026quot;\u0026lt;pass-name\u0026gt;\u0026quot; }}  Use gpg to keep your secrets #  chezmoi supports encrypting files with gpg. Encrypted files are stored in the source state and automatically be decrypted when generating the target state or printing a file\u0026rsquo;s contents with chezmoi cat. chezmoi edit will transparently decrypt the file before editing and re-encrypt it afterwards.\nAsymmetric (private/public-key) encryption #  Specify the encryption key to use in your configuration file (chezmoi.toml) with the gpg.recipient key:\n[gpg] recipient = \u0026quot;...\u0026quot;  Add files to be encrypted with the --encrypt flag, for example:\nchezmoi add --encrypt ~/.ssh/id_rsa  chezmoi will encrypt the file with:\ngpg --armor --recipient ${gpg.recipient} --encrypt  and store the encrypted file in the source state. The file will automatically be decrypted when generating the target state.\nSymmetric encryption #  Specify symmetric encryption in your configuration file:\n[gpg] symmetric = true  Add files to be encrypted with the --encrypt flag, for example:\nchezmoi add --encrypt ~/.ssh/id_rsa  chezmoi will encrypt the file with:\ngpg --armor --symmetric  Use KeePassXC to keep your secrets #  chezmoi includes support for KeePassXC using the KeePassXC CLI (keepassxc-cli) to expose data as a template function.\nProvide the path to your KeePassXC database in your configuration file:\n[keepassxc] database = \u0026quot;/home/user/Passwords.kdbx\u0026quot;  The structured data from keepassxc-cli show $database is available as the keepassxc template function in your config files, for example:\nusername = {{ (keepassxc \u0026quot;example.com\u0026quot;).UserName }} password = {{ (keepassxc \u0026quot;example.com\u0026quot;).Password }}  Additional attributes are available through the keepassxcAttribute function. For example, if you have an entry called SSH Key with an additional attribute called private-key, its value is available as:\n{{ keepassxcAttribute \u0026quot;SSH Key\u0026quot; \u0026quot;private-key\u0026quot; }}  Use LastPass to keep your secrets #  chezmoi includes support for LastPass using the LastPass CLI to expose data as a template function.\nLog in to LastPass using:\nlpass login \u0026lt;lastpass-username\u0026gt;  Check that lpass is working correctly by showing password data:\nlpass show --json \u0026lt;lastpass-entry-id\u0026gt;  where \u0026lt;lastpass-entry-id\u0026gt; is a LastPass Entry Specification.\nThe structured data from lpass show --json id is available as the lastpass template function. The value will be an array of objects. You can use the index function and .Field syntax of the text/template language to extract the field you want. For example, to extract the password field from first the \u0026ldquo;GitHub\u0026rdquo; entry, use:\ngithubPassword = \u0026quot;{{ (index (lastpass \u0026quot;GitHub\u0026quot;) 0).password }}\u0026quot;  chezmoi automatically parses the note value of the Lastpass entry as colon-separated key-value pairs, so, for example, you can extract a private SSH key like this:\n{{ (index (lastpass \u0026quot;SSH\u0026quot;) 0).note.privateKey }}  Keys in the note section written as CamelCase Words are converted to camelCaseWords.\nIf the note value does not contain colon-separated key-value pairs, then you can use lastpassRaw to get its raw value, for example:\n{{ (index (lastpassRaw \u0026quot;SSH Private Key\u0026quot;) 0).note }}  Use 1Password to keep your secrets #  chezmoi includes support for 1Password using the 1Password CLI to expose data as a template function.\nLog in and get a session using:\neval $(op signin \u0026lt;subdomain\u0026gt;.1password.com \u0026lt;email\u0026gt;)  The output of op get item \u0026lt;uuid\u0026gt; is available as the onepassword template function. chezmoi parses the JSON output and returns it as structured data. For example, if the output of op get item \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; is:\n{ \u0026quot;uuid\u0026quot;: \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot;, \u0026quot;details\u0026quot;: { \u0026quot;password\u0026quot;: \u0026quot;xxx\u0026quot; } }  Then you can access details.password with the syntax:\n{{ (onepassword \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot;).details.password }}  Login details fields can be retrieved with the onepasswordDetailsFields function, for example:\n{{- (onepasswordDetailsFields \u0026quot;uuid\u0026quot;).password.value }}  Documents can be retrieved with:\n{{- onepasswordDocument \u0026quot;uuid\u0026quot; -}}  Note the extra - after the opening {{ and before the closing }}. This instructs the template language to remove and whitespace before and after the substitution. This removes any trailing newline added by your editor when saving the template.\nUse pass to keep your secrets #  chezmoi includes support for pass using the pass CLI.\nThe first line of the output of pass show \u0026lt;pass-name\u0026gt; is available as the pass template function, for example:\n{{ pass \u0026quot;\u0026lt;pass-name\u0026gt;\u0026quot; }}  Use Vault to keep your secrets #  chezmoi includes support for Vault using the Vault CLI to expose data as a template function.\nThe vault CLI needs to be correctly configured on your machine, e.g. the VAULT_ADDR and VAULT_TOKEN environment variables must be set correctly. Verify that this is the case by running:\nvault kv get -format=json \u0026lt;key\u0026gt;  The structured data from vault kv get -format=json is available as the vault template function. You can use the .Field syntax of the text/template language to extract the data you want. For example:\n{{ (vault \u0026quot;\u0026lt;key\u0026gt;\u0026quot;).data.data.password }}  Use a generic tool to keep your secrets #  You can use any command line tool that outputs secrets either as a string or in JSON format. Choose the binary by setting genericSecret.command in your configuration file. You can then invoke this command with the secret and secretJSON template functions which return the raw output and JSON-decoded output respectively. All of the above secret managers can be supported in this way:\n   Secret Manager genericSecret.command Template skeleton     1Password op {{ secretJSON \u0026quot;get\u0026quot; \u0026quot;item\u0026quot; \u0026lt;id\u0026gt; }}   Bitwarden bw {{ secretJSON \u0026quot;get\u0026quot; \u0026lt;id\u0026gt; }}   Hashicorp Vault vault {{ secretJSON \u0026quot;kv\u0026quot; \u0026quot;get\u0026quot; \u0026quot;-format=json\u0026quot; \u0026lt;id\u0026gt; }}   LastPass lpass {{ secretJSON \u0026quot;show\u0026quot; \u0026quot;--json\u0026quot; \u0026lt;id\u0026gt; }}   KeePassXC keepassxc-cli Not possible (interactive command only)   pass pass {{ secret \u0026quot;show\u0026quot; \u0026lt;id\u0026gt; }}    Use templates variables to keep your secrets #  Typically, ~/.config/chezmoi/chezmoi.toml is not checked in to version control and has permissions 0600. You can store tokens as template values in the data section. For example, if your ~/.config/chezmoi/chezmoi.toml contains:\n[data] [data.github] user = \u0026quot;\u0026lt;github-username\u0026gt;\u0026quot; token = \u0026quot;\u0026lt;github-token\u0026gt;\u0026quot;  Your ~/.local/share/chezmoi/private_dot_gitconfig.tmpl can then contain:\n{{- if (index . \u0026quot;github\u0026quot;) }} [github] user = \u0026quot;{{ .github.user }}\u0026quot; token = \u0026quot;{{ .github.token }}\u0026quot; {{- end }}  Any config files containing tokens in plain text should be private (permissions 0600).\nUse scripts to perform actions #  Understand how scripts work #  chezmoi supports scripts, which are executed when you run chezmoi apply. The scripts can either run every time you run chezmoi apply, or only when their contents have changed.\nIn verbose mode, the script\u0026rsquo;s contents will be printed before executing it. In dry-run mode, the script is not executed.\nScripts are any file in the source directory with the prefix run_, and are executed in alphabetical order. Scripts that should only be run when their contents change have the prefix run_once_.\nScripts break chezmoi\u0026rsquo;s declarative approach, and as such should be used sparingly. Any script should be idempotent, even run_once_ scripts.\nScripts must be created manually in the source directory, typically by running chezmoi cd and then creating a file with a run_ prefix. Scripts are executed directly using exec and must include a shebang line or be executable binaries. There is no need to set the executable bit on the script.\nScripts with the suffix .tmpl are treated as templates, with the usual template variables available. If, after executing the template, the result is only whitespace or an empty string, then the script is not executed. This is useful for disabling scripts.\nInstall packages with scripts #  Change to the source directory and create a file called run_once_install-packages.sh:\nchezmoi cd $EDITOR run_once_install-packages.sh  In this file create your package installation script, e.g.\n#!/bin/sh sudo apt install ripgrep  The next time you run chezmoi apply or chezmoi update this script will be run. As it has the run_once_ prefix, it will not be run again unless its contents change, for example if you add more packages to be installed.\nThis script can also be a template. For example, if you create run_once_install-packages.sh.tmpl with the contents:\n{{ if eq .chezmoi.os \u0026quot;linux\u0026quot; -}} #!/bin/sh sudo apt install ripgrep {{ else if eq .chezmoi.os \u0026quot;darwin\u0026quot; -}} #!/bin/sh brew install ripgrep {{ end -}}  This will install ripgrep on both Debian/Ubuntu Linux systems and macOS.\nUse chezmoi with GitHub Codespaces, Visual Studio Codespaces, Visual Studio Code Remote - Containers #  The following assumes you are using chezmoi 1.8.4 or later. It does not work with earlier versions of chezmoi.\nYou can use chezmoi to manage your dotfiles in GitHub Codespaces, Visual Studio Codespaces, and Visual Studio Code Remote - Containers.\nFor a quick start, you can clone the chezmoi/dotfiles repository which supports Codespaces out of the box.\nThe workflow is different to using chezmoi on a new machine, notably:\n These systems will automatically clone your dotfiles repo to ~/dotfiles, so there is no need to clone your repo yourself. The installation script must be non-interactive. When running in a Codespace, the environment variable CODESPACES will be set to true. You can read its value with the env template function.  First, if you are using a chezmoi configuration file template, ensure that it is non-interactive when running in codespaces, for example, .chezmoi.toml.tmpl might contain:\n{{- $codespaces:= env \u0026quot;CODESPACES\u0026quot; | not | not -}} sourceDir = \u0026quot;{{ .chezmoi.sourceDir }}\u0026quot; [data] name = \u0026quot;Your name\u0026quot; codespaces = {{ $codespaces }} {{- if $codespaces }}{{/* Codespaces dotfiles setup is non-interactive, so set an email address */}} email = \u0026quot;your@email.com\u0026quot; {{- else }}{{/* Interactive setup, so prompt for an email address */}} email = \u0026quot;{{ promptString \u0026quot;email\u0026quot; }}\u0026quot; {{- end }} This sets the codespaces template variable, so you don\u0026rsquo;t have to repeat (env \u0026quot;CODESPACES\u0026quot;) in your templates. It also sets the sourceDir configuration to the --source argument passed in chezmoi init.\nSecond, create an install.sh script that installs chezmoi and your dotfiles:\n#!/bin/sh  set -e # -e: exit on error if [ ! \u0026#34;$(command -v chezmoi)\u0026#34; ]; then bin_dir=\u0026#34;$HOME/.local/bin\u0026#34; chezmoi=\u0026#34;$bin_dir/chezmoi\u0026#34; if [ \u0026#34;$(command -v curl)\u0026#34; ]; then sh -c \u0026#34;$(curl -fsSL https://git.io/chezmoi)\u0026#34; -- -b \u0026#34;$bin_dir\u0026#34; elif [ \u0026#34;$(command -v wget)\u0026#34; ]; then sh -c \u0026#34;$(wget -qO- https://git.io/chezmoi)\u0026#34; -- -b \u0026#34;$bin_dir\u0026#34; else echo \u0026#34;To install chezmoi, you must have curl or wget installed.\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi else chezmoi=chezmoi fi # POSIX way to get script\u0026#39;s dir: https://stackoverflow.com/a/29834779/12156188 script_dir=\u0026#34;$(cd -P -- \u0026#34;$(dirname -- \u0026#34;$(command -v -- \u0026#34;$0\u0026#34;)\u0026#34;)\u0026#34; \u0026amp;\u0026amp; pwd -P)\u0026#34; # exec: replace current process with chezmoi init exec \u0026#34;$chezmoi\u0026#34; init --apply \u0026#34;--source=$script_dir\u0026#34; Ensure that this file is executable (chmod a+x install.sh), and add install.sh to your .chezmoiignore file.\nIt installs the latest version of chezmoi in ~/.local/bin if needed, and then chezmoi init ... invokes chezmoi to create its configuration file and initialize your dotfiles. --apply tells chezmoi to apply the changes immediately, and --source=... tells chezmoi where to find the cloned dotfiles repo, which in this case is the same folder in which the script is running from.\nIf you do not use a chezmoi configuration file template you can use chezmoi apply --source=$HOME/dotfiles instead of chezmoi init ... in install.sh.\nFinally, modify any of your templates to use the codespaces variable if needed. For example, to install vim-gtk on Linux but not in Codespaces, your run_once_install-packages.sh.tmpl might contain:\n{{- if (and (eq .chezmoi.os \u0026quot;linux\u0026quot;)) (not .codespaces))) -}} #!/bin/sh sudo apt install -y vim-gtk {{- end -}} Detect Windows Services for Linux (WSL) #  WSL can be detected by looking for the string Microsoft in /proc/kernel/osrelease, which is available in the template variable .chezmoi.kernel.osrelease, for example:\nWSL 1:\n{{ if (contains \u0026quot;Microsoft\u0026quot; .chezmoi.kernel.osrelease) }} # WSL-specific code {{ end }} WSL 2:\n{{ if (contains \u0026quot;microsoft\u0026quot; .chezmoi.kernel.osrelease) }} # WSL-specific code {{ end }} WSL 2 since version 4.19.112:\n{{ if (contains \u0026quot;microsoft-WSL2\u0026quot; .chezmoi.kernel.osrelease) }} # WSL-specific code {{ end }} Run a PowerShell script as admin on Windows #  Put the following at the top of your script:\n# Self-elevate the script if required if (-Not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] \u0026#39;Administrator\u0026#39;)) { if ([int](Get-CimInstance -Class Win32_OperatingSystem | Select-Object -ExpandProperty BuildNumber) -ge 6000) { $CommandLine = \u0026#34;-NoExit -File `\u0026#34;\u0026#34; + $MyInvocation.MyCommand.Path + \u0026#34;`\u0026#34;\u0026#34; + $MyInvocation.UnboundArguments Start-Process -FilePath PowerShell.exe -Verb Runas -ArgumentList $CommandLine Exit } } Import archives #  It is occasionally useful to import entire archives of configuration into your source state. The import command does this. For example, to import the latest version github.com/robbyrussell/oh-my-zsh to ~/.oh-my-zsh run:\ncurl -s -L -o oh-my-zsh-master.tar.gz https://github.com/robbyrussell/oh-my-zsh/archive/master.tar.gz chezmoi import --strip-components 1 --destination ~/.oh-my-zsh oh-my-zsh-master.tar.gz  Note that this only updates the source state. You will need to run\nchezmoi apply  to update your destination directory.\nExport archives #  chezmoi can create an archive containing the target state. This can be useful for generating target state on a different machine or for simply inspecting the target state. A particularly useful command is:\nchezmoi archive | tar tvf -  which lists all the targets in the target state.\nUse a non-git version control system #  By default, chezmoi uses git, but you can use any version control system of your choice. In your config file, specify the command to use. For example, to use Mercurial specify:\n[sourceVCS] command = \u0026quot;hg\u0026quot;  The source VCS command is used in the chezmoi commands init, source, and update, and support for VCSes other than git is limited but easy to add. If you\u0026rsquo;d like to see your VCS better supported, please open an issue on GitHub.\nCustomize the diff command #  By default, chezmoi uses a built-in diff. You can change the format, and/or pipe the output into a pager of your choice. For example, to use diff-so-fancy specify:\n[diff] format = \u0026quot;git\u0026quot; pager = \u0026quot;diff-so-fancy\u0026quot;  The format can also be set with the --format option to the diff command, and the pager can be disabled using --no-pager.\nUse a merge tool other than vimdiff #  By default, chezmoi uses vimdiff, but you can use any merge tool of your choice. In your config file, specify the command and args to use. For example, to use neovim\u0026rsquo;s diff mode specify:\n[merge] command = \u0026quot;nvim\u0026quot; args = \u0026quot;-d\u0026quot;  Migrate from a dotfile manager that uses symlinks #  Many dotfile managers replace dotfiles with symbolic links to files in a common directory. If you chezmoi add such a symlink, chezmoi will add the symlink, not the file. To assist with migrating from symlink-based systems, use the --follow option to chezmoi add, for example:\nchezmoi add --follow ~/.bashrc  This will tell chezmoi add that the target state of ~/.bashrc is the target of the ~/.bashrc symlink, rather than the symlink itself. When you run chezmoi apply, chezmoi will replace the ~/.bashrc symlink with the file contents.\n"});index.add({'id':5,'href':'/docs/install/','title':"Install",'section':"Docs",'content':"Install Guide #  One-line binary install #  Install the correct binary for your operating system and architecture in ./bin with a single command.\ncurl -sfL https://git.io/chezmoi | sh  One-line package install #  Install chezmoi with a single command.\n   OS Method Command     Linux snap snap install chezmoi --classic   Linux Linuxbrew brew install chezmoi   Alpine Linux apk apk add chezmoi   Arch Linux pacman pacman -S chezmoi   Guix Linux guix guix install chezmoi   NixOS Linux nix-env nix-env -i chezmoi   macOS Homebrew brew install chezmoi   macOS MacPorts sudo port install chezmoi   Windows Scoop scoop bucket add twpayne https://github.com/twpayne/scoop-bucket \u0026amp;\u0026amp; scoop install chezmoi   Windows Chocolatey choco install chezmoi    Pre-built Linux packages #  Download a package for your operating system and architecture and install it with your package manager.\n   Distribution Architectures Package     Debian amd64, arm64, armel, i386, ppc64, ppc64le deb   RedHat aarch64, armhfp, i686, ppc64, ppc64le, x86_64 rpm   OpenSUSE aarch64, armhfp, i686, ppc64, ppc64le, x86_64 rpm   Ubuntu amd64, arm64, armel, i386, ppc64, ppc64le deb    Pre-built binaries #  Download an archive for your operating system containing a pre-built binary, documentation, and shell completions.\n   OS Architectures Archive     FreeBSD amd64, arm, arm64, i386 tar.gz   Linux amd64, arm, arm64, i386, ppc64, ppc64le tar.gz   macOS amd64 tar.gz   OpenBSD amd64, arm, arm64, i386 tar.gz   Windows amd64, i386 zip    All pre-built Linux packages and binaries #  All pre-built binaries and packages can be found on the chezmoi GitHub releases page.\nFrom source #  Download, build, and install chezmoi for your system:\ncd $(mktemp -d) git clone --depth=1 https://github.com/twpayne/chezmoi.git cd chezmoi go install  Building chezmoi requires Go 1.13 or later.\nUpgrading #  If you have installed a pre-built binary of chezmoi, you can upgrade it to the latest release with:\nchezmoi upgrade  This will re-use whichever mechanism you used to install chezmoi to install the latest release.\n"});index.add({'id':6,'href':'/docs/media/','title':"Media",'section':"Docs",'content':"Media #     Date Version Format Link     2020-08-09 1.8.3 Text Automating and testing dotfiles   2020-07-06 1.8.3 Video chezmoi: Manage your dotfiles across multiple machines, securely.   2020-07-03 1.8.3 Text Feeling at home in a LXD container   2020-06-15 1.8.2 Text Dotfiles management using chezmoi - How I Use Linux Desktop at Work Part5   2020-04-27 1.8.0 Text Managing my dotfiles with chezmoi   2020-04-16 1.17.19 Text (FR) Chezmoi, visite guidée   2020-04-03 1.7.17 Text Fedora Magazine: Take back your dotfiles with Chezmoi   2020-04-01 1.7.17 Text Managing dotfiles and secret with chezmoi   2020-03-12 1.7.16 Video Managing Dotfiles with ChezMoi   2019-11-20 1.7.2 Audio/video FLOSS weekly episode 556: chezmoi   2019-01-10 0.0.11 Text Linux Fu: The kitchen sync    To add your article to this page please either open an issue or submit a pull request that modifies this file (docs/MEDIA.md).\n"});index.add({'id':7,'href':'/docs/quick-start/','title':"Quick Start",'section':"Docs",'content':"Quick Start Guide #  Concepts #  chezmoi stores the desired state of your dotfiles in the directory ~/.local/share/chezmoi. When you run chezmoi apply, chezmoi calculates the desired contents and permissions for each dotfile and then makes any changes necessary so that your dotfiles match that state.\nStart using chezmoi on your current machine #  Initialize chezmoi:\nchezmoi init  This will create a new git repository in ~/.local/share/chezmoi with permissions 0700 where chezmoi will store the source state. chezmoi only modifies files in the working copy. It is your responsibility to commit changes.\nManage an existing file with chezmoi:\nchezmoi add ~/.bashrc  This will copy ~/.bashrc to ~/.local/share/chezmoi/dot_bashrc. If you want to add a whole folder to chezmoi, you have to add the -r argument after add.\nEdit the source state:\nchezmoi edit ~/.bashrc  This will open ~/.local/share/chezmoi/dot_bashrc in your $EDITOR. Make some changes and save them.\nSee what changes chezmoi would make:\nchezmoi diff  Apply the changes:\nchezmoi -v apply  All chezmoi commands accept the -v (verbose) flag to print out exactly what changes they will make to the file system, and the -n (dry run) flag to not make any actual changes. The combination -n -v is very useful if you want to see exactly what changes would be made.\nFinally, open a shell in the source directory, commit your changes, and return to where you were:\nchezmoi cd git add dot_bashrc git commit -m \u0026quot;Add .bashrc\u0026quot; exit  Using chezmoi across multiple machines #  Clone the git repo in ~/.local/share/chezmoi to a hosted Git service, e.g. GitHub, GitLab, or BitBucket. Many people call their dotfiles repo dotfiles. You can then setup chezmoi on a second machine:\nchezmoi init https://github.com/username/dotfiles.git  This will check out the repo and any submodules and optionally create a chezmoi config file for you. It won\u0026rsquo;t make any changes to your home directory until you run:\nchezmoi apply  On any machine, you can pull and apply the latest changes from your repo with:\nchezmoi update  Next steps #  For a full list of commands run:\nchezmoi help  chezmoi has much more functionality. Read the how-to guide to explore.\n"});index.add({'id':8,'href':'/docs/reference/','title':"Reference",'section':"Docs",'content':"Reference Manual #  Concepts #  chezmoi evaluates the source state for the current machine and then updates the destination directory, where:\n  The source state declares the desired state of your home directory, including templates and machine-specific configuration.\n  The source directory is where chezmoi stores the source state, by default ~/.local/share/chezmoi.\n  The target state is the source state computed for the current machine.\n  The destination directory is the directory that chezmoi manages, by default ~, your home directory.\n  A target is a file, directory, or symlink in the destination directory.\n  The destination state is the current state of all the targets in the destination directory.\n  The config file contains machine-specific configuration, by default it is ~/.config/chezmoi/chezmoi.toml.\n  Global command line flags #  Command line flags override any values set in the configuration file.\n--color value #  Colorize diffs, value can be on, off, auto, or any boolean-like value recognized by strconv.ParseBool. The default value is auto which will colorize diffs only if the the environment variable NO_COLOR is not set and stdout is a terminal.\n-c, --config filename #  Read the configuration from filename.\n--debug #  Log information helpful for debugging.\n-D, --destination directory #  Use directory as the destination directory.\n--follow #  If the last part of a target is a symlink, deal with what the symlink references, rather than the symlink itself.\n-n, --dry-run #  Set dry run mode. In dry run mode, the destination directory is never modified. This is most useful in combination with the -v (verbose) flag to print changes that would be made without making them.\n-h, --help #  Print help.\n-r. --remove #  Also remove targets according to .chezmoiremove.\n-S, --source directory #  Use directory as the source directory.\n-v, --verbose #  Set verbose mode. In verbose mode, chezmoi prints the changes that it is making as approximate shell commands, and any differences in files between the target state and the destination set are printed as unified diffs.\n--version #  Print the version of chezmoi, the commit at which it was built, and the build timestamp.\nConfiguration file #  chezmoi searches for its configuration file according to the XDG Base Directory Specification and supports all formats supported by github.com/spf13/viper, namely JSON, TOML, YAML, macOS property file format, and HCL. The basename of the config file is chezmoi, and the first config file found is used.\nVariables #  The following configuration variables are available:\n   Section Variable Type Default value Description     Top level color string auto Colorize diffs    data any none Template data    destDir string ~ Destination directory    dryRun bool false Dry run mode    follow bool false Follow symlinks    remove bool false Remove targets    sourceDir string ~/.local/share/chezmoi Source directory    umask int from system Umask    verbose bool false Verbose mode   bitwarden command string bw Bitwarden CLI command   cd args []string none Extra args to shell in cd command    command string none Shell to run in cd command   diff format string chezmoi Diff format, either chezmoi or git    pager string none Pager   genericSecret command string none Generic secret command   gopass command string gopass gopass CLI command   gpg command string gpg GPG CLI command    recipient string none GPG recipient    symmetric bool false Use symmetric GPG encryption   keepassxc args []string none Extra args to KeePassXC CLI command    command string keepassxc-cli KeePassXC CLI command    database string none KeePassXC database   lastpass command string lpass Lastpass CLI command   merge args []string none Extra args to 3-way merge command    command string vimdiff 3-way merge command   onepassword command string op 1Password CLI command   pass command string pass Pass CLI command   sourceVCS autoCommit bool false Commit changes to the source state after any change    autoPush bool false Push changes to the source state after any change    command string git Source version control system   template options []string [\u0026quot;missingkey=error\u0026quot;] Template options   vault command string vault Vault CLI command    Examples #  JSON #  { \u0026#34;sourceDir\u0026#34;: \u0026#34;/home/user/.dotfiles\u0026#34;, \u0026#34;diff\u0026#34;: { \u0026#34;format\u0026#34;: \u0026#34;git\u0026#34; } } TOML #  sourceDir = \u0026#34;/home/user/.dotfiles\u0026#34; [diff] format = \u0026#34;git\u0026#34; YAML #  sourceDir: /home/user/.dotfiles diff: format: git Source state attributes #  chezmoi stores the source state of files, symbolic links, and directories in regular files and directories in the source directory (~/.local/share/chezmoi by default). This location can be overridden with the -S flag or by giving a value for sourceDir in ~/.config/chezmoi/chezmoi.toml. Some state is encoded in the source names. chezmoi ignores all files and directories in the source directory that begin with a .. The following prefixes and suffixes are special, and are collectively referred to as \u0026ldquo;attributes\u0026rdquo;:\n   Prefix Effect     encrypted_ Encrypt the file in the source state.   once_ Only run script once.   private_ Remove all group and world permissions from the target file or directory.   empty_ Ensure the file exists, even if is empty. By default, empty files are removed.   exact_ Remove anything not managed by chezmoi.   executable_ Add executable permissions to the target file.   run_ Treat the contents as a script to run.   symlink_ Create a symlink instead of a regular file.   dot_ Rename to use a leading dot, e.g. dot_foo becomes .foo.       Suffix Effect     .tmpl Treat the contents of the source file as a template.    Order of prefixes is important, the order is run_, exact_, private_, empty_, executable_, symlink_, once_, dot_.\nDifferent target types allow different prefixes and suffixes:\n   Target type Allowed prefixes Allowed suffixes     Directory exact_, private_, dot_ none   Regular file encrypted_, private_, empty_, executable_, dot_ .tmpl   Script run_, once_ .tmpl   Symbolic link symlink_, dot_, .tmpl    Special files and directories #  All files and directories in the source state whose name begins with . are ignored by default, unless they are one of the special files listed here.\n.chezmoi.\u0026lt;format\u0026gt;.tmpl #  If a file called .chezmoi.\u0026lt;format\u0026gt;.tmpl exists then chezmoi init will use it to create an initial config file. format must be one of the the supported config file formats.\n.chezmoi.\u0026lt;format\u0026gt;.tmpl examples #  {{ $email := promptString \u0026quot;email\u0026quot; -}} data: email: \u0026quot;{{ $email }}\u0026quot;  .chezmoiignore #  If a file called .chezmoiignore exists in the source state then it is interpreted as a set of patterns to ignore. Patterns are matched using doublestar.PathMatch and match against the target path, not the source path.\nPatterns can be excluded by prefixing them with a ! character. All excludes take priority over all includes.\nComments are introduced with the # character and run until the end of the line.\n.chezmoiignore is interpreted as a template. This allows different files to be ignored on different machines.\n.chezmoiignore files in subdirectories apply only to that subdirectory.\n.chezmoiignore examples #  README.md *.txt # ignore *.txt in the target directory */*.txt # ignore *.txt in subdirectories of the target directory backups/** # ignore backups folder in chezmoi directory and all its contents {{- if ne .email \u0026quot;john.smith@company.com\u0026quot; }} # Ignore .company-directory unless configured with a company email .company-directory # note that the pattern is not dot_company-directory {{- end }} {{- if ne .email \u0026quot;john@home.org }} .personal-file {{- end }}  .chezmoiremove #  If a file called .chezmoiremove exists in the source state then it is interpreted as a list of targets to remove. .chezmoiremove is interpreted as a template.\n.chezmoitemplates #  If a directory called .chezmoitemplates exists, then all files in this directory are parsed as templates are available as templates with a name equal to the relative path of the file.\n.chezmoitemplates examples #  Given:\n.chezmoitemplates/foo {{ if true }}bar{{ end }} dot_config.tmpl {{ template \u0026quot;foo\u0026quot; }}  The target state of .config will be bar.\n.chezmoiversion #  If a file called .chezmoiversion exists, then its contents are interpreted as a semantic version defining the minimum version of chezmoi required to interpret the source state correctly. chezmoi will refuse to interpret the source state if the current version is too old.\nWarning support for .chezmoiversion will be introduced in a future version (likely 1.5.0). Earlier versions of chezmoi will ignore this file.\n.chezmoiversion examples #  1.5.0  Commands #  add targets #  Add targets to the source state. If any target is already in the source state, then its source state is replaced with its current state in the destination directory. The add command accepts additional flags:\n--autotemplate #  Automatically generate a template by replacing strings with variable names from the data section of the config file. Longer substitutions occur before shorter ones. This implies the --template option.\n-e, --empty #  Set the empty attribute on added files.\n-f, --force #  Add targets, even if doing so would cause a source template to be overwritten.\n-x, --exact #  Set the exact attribute on added directories.\n-p, --prompt #  Interactively prompt before adding each file.\n-r, --recursive #  Recursively add all files, directories, and symlinks.\n-T, --template #  Set the template attribute on added files and symlinks.\nadd examples #  chezmoi add ~/.bashrc chezmoi add ~/.gitconfig --template chezmoi add ~/.vim --recursive chezmoi add ~/.oh-my-zsh --exact --recursive  apply [targets] #  Ensure that targets are in the target state, updating them if necessary. If no targets are specified, the state of all targets are ensured.\napply examples #  chezmoi apply chezmoi apply --dry-run --verbose chezmoi apply ~/.bashrc  archive #  Generate a tar archive of the target state. This can be piped into tar to inspect the target state.\n--output, -o filename #  Write the output to filename instead of stdout.\narchive examples #  chezmoi archive | tar tvf - chezmoi archive --output=dotfiles.tar  cat targets #  Write the target state of targets to stdout. targets must be files or symlinks. For files, the target file contents are written. For symlinks, the target target is written.\ncat examples #  chezmoi cat ~/.bashrc  cd #  Launch a shell in the source directory. chezmoi will launch the command set by the cd.command configuration variable with any extra arguments specified by cd.args. If this is not set, chezmoi will attempt to detect your shell and will finally fall back to an OS-specific default.\ncd examples #  chezmoi cd  chattr attributes targets #  Change the attributes of targets. attributes specifies which attributes to modify. Add attributes by specifying them or their abbreviations directly, optionally prefixed with a plus sign (+). Remove attributes by prefixing them or their attributes with the string no or a minus sign (-). The available attributes and their abbreviations are:\n   Attribute Abbreviation     empty e   encrypted none   exact none   executable x   private p   template t    Multiple attributes modifications may be specified by separating them with a comma (,).\nchattr examples #  chezmoi chattr template ~/.bashrc chezmoi chattr noempty ~/.profile chezmoi chattr private,template ~/.netrc  completion shell #  Generate shell completion code for the specified shell (bash, fish, or zsh).\n--output, -o filename #  Write the shell completion code to filename instead of stdout.\ncompletion examples #  chezmoi completion bash chezmoi completion fish --output ~/.config/fish/completions/chezmoi.fish  data #  Write the computed template data in JSON format to stdout. The data command accepts additional flags:\n-f, --format format #  Print the computed template data in the given format. The accepted formats are json (JSON), toml (TOML), and yaml (YAML).\ndata examples #  chezmoi data chezmoi data --format=yaml  diff [targets] #  Print the difference between the target state and the destination state for targets. If no targets are specified, print the differences for all targets.\nIf a diff.pager command is set in the configuration file then the output will be piped into it.\n-f, --format format #  Print the diff in format. The format can be set with the diff.format variable in the configuration file. Valid formats are:\nchezmoi #  A mix of unified diffs and pseudo shell commands, including scripts, equivalent to chezmoi apply --dry-run --verbose.\ngit #  A git format diff, excluding scripts. In version 2.0.0 of chezmoi, git format diffs will become the default and include scripts and the chezmoi format will be removed.\n--no-pager #  Do not use the pager.\ndiff examples #  chezmoi diff chezmoi diff ~/.bashrc chezmoi diff --format=git  docs [regexp] #  Print the documentation page matching the regular expression regexp. Matching is case insensitive. If no pattern is given, print REFERENCE.md.\ndocs examples #  chezmoi docs chezmoi docs faq chezmoi docs howto  doctor #  Check for potential problems.\ndoctor examples #  chezmoi doctor  dump [targets] #  Dump the target state in JSON format. If no targets are specified, then the entire target state. The dump command accepts additional arguments:\n-f, --format format #  Print the target state in the given format. The accepted formats are json (JSON) and yaml (YAML).\ndump examples #  chezmoi dump ~/.bashrc chezmoi dump --format=yaml  edit [targets] #  Edit the source state of targets, which must be files or symlinks. If no targets are given the the source directory itself is opened with $EDITOR. The edit command accepts additional arguments:\n-a, --apply #  Apply target immediately after editing. Ignored if there are no targets.\n-d, --diff #  Print the difference between the target state and the actual state after editing.. Ignored if there are no targets.\n-p, --prompt #  Prompt before applying each target.. Ignored if there are no targets.\nedit examples #  chezmoi edit ~/.bashrc chezmoi edit ~/.bashrc --apply --prompt chezmoi edit  edit-config #  Edit the configuration file.\nedit-config examples #  chezmoi edit-config  execute-template [templates] #  Execute templates. This is useful for testing templates or for calling chezmoi from other scripts. templates are interpreted as literal templates, with no whitespace added to the output between arguments. If no templates are specified, the template is read from stdin.\n--init, -i #  Include simulated functions only available during chezmoi init.\n--output, -o filename #  Write the output to filename instead of stdout.\n--promptString, -p pairs #  Simulate the promptString function with a function that returns values from pairs. pairs is a comma-separated list of prompt=value pairs. If promptString is called with a prompt that does not match any of pairs, then it returns prompt unchanged.\nexecute-template examples #  chezmoi execute-template '{{ .chezmoi.sourceDir }}' chezmoi execute-template '{{ .chezmoi.os }}' / '{{ .chezmoi.arch }}' echo '{{ .chezmoi | toJson }}' | chezmoi execute-template chezmoi execute-template --init --promptString email=john@home.org \u0026lt; ~/.local/share/chezmoi/.chezmoi.toml.tmpl  forget targets #  Remove targets from the source state, i.e. stop managing them.\nforget examples #  chezmoi forget ~/.bashrc  git [arguments] #  Run git arguments in the source directory. Note that flags in arguments must occur after -- to prevent chezmoi from interpreting them.\ngit examples #  chezmoi git add . chezmoi git add dot_gitconfig chezmoi git -- commit -m \u0026quot;Add .gitconfig\u0026quot;  help command #  Print the help associated with command.\nhg [arguments] #  Run hg arguments in the source directory. Note that flags in arguments must occur after -- to prevent chezmoi from interpreting them.\nhg examples #  chezmoi hg -- pull --rebase --update  init [repo] #  Setup the source directory and update the destination directory to match the target state.\nFirst, if the source directory is not already contain a repository, then if repo is given it is checked out into the source directory, otherwise a new repository is initialized in the source directory.\nSecond, if a file called .chezmoi.format.tmpl exists, where format is one of the supported file formats (e.g. json, toml, or yaml) then a new configuration file is created using that file as a template.\nFinally, if the --apply flag is passed, chezmoi apply is run.\n--apply #  Run chezmoi apply after checking out the repo and creating the config file. This is false by default.\ninit examples #  chezmoi init https://github.com/user/dotfiles.git chezmoi init https://github.com/user/dotfiles.git --apply  import filename #  Import the source state from an archive file in to a directory in the source state. This is primarily used to make subdirectories of your home directory exactly match the contents of a downloaded archive. You will generally always want to set the --destination, --exact, and --remove-destination flags.\nThe only supported archive format is .tar.gz.\n--destination directory #  Set the destination (in the source state) where the archive will be imported.\n-x, --exact #  Set the exact attribute on all imported directories.\n-r, --remove-destination #  Remove destination (in the source state) before importing.\n--strip-components n #  Strip n leading components from paths.\nimport examples #  curl -s -L -o oh-my-zsh-master.tar.gz https://github.com/robbyrussell/oh-my-zsh/archive/master.tar.gz chezmoi import --strip-components 1 --destination ~/.oh-my-zsh oh-my-zsh-master.tar.gz  manage targets #  manage is an alias for add for symmetry with unmanage.\nmanaged #  List all managed entries in the destination directory in alphabetical order.\n-i, --include types #  Only list entries of type types. types is a comma-separated list of types of entry to include. Valid types are dirs, files, and symlinks which can be abbreviated to d, f, and s respectively. By default, manage will list entries of all types.\nmanaged examples #  chezmoi managed chezmoi managed --include=files chezmoi managed --include=files,symlinks chezmoi managed -i d chezmoi managed -i d,f  merge targets #  Perform a three-way merge between the destination state, the source state, and the target state. The merge tool is defined by the merge.command configuration variable, and defaults to vimdiff. If multiple targets are specified the merge tool is invoked for each target. If the target state cannot be computed (for example if source is a template containing errors or an encrypted file that cannot be decrypted) a two-way merge is performed instead.\nmerge examples #  chezmoi merge ~/.bashrc  purge #  Remove chezmoi\u0026rsquo;s configuration, state, and source directory, but leave the target state intact.\n-f, --force #  Remove without prompting.\npurge examples #  chezmoi purge chezmoi purge --force  remove targets #  Remove targets from both the source state and the destination directory.\n-f, --force #  Remove without prompting.\nrm targets #  rm is an alias for remove.\nsecret #  Run a secret manager\u0026rsquo;s CLI, passing any extra arguments to the secret manager\u0026rsquo;s CLI. This is primarily for verifying chezmoi\u0026rsquo;s integration with your secret manager. Normally you would use template functions to retrieve secrets. Note that if you want to pass flags to the secret manager\u0026rsquo;s CLI you will need to separate them with -- to prevent chezmoi from interpreting them.\nTo get a full list of available commands run:\nchezmoi secret help  secret examples #  chezmoi secret bitwarden list items chezmoi secret lastpass ls chezmoi secret lastpass -- show --format=json id chezmoi secret onepassword list items chezmoi secret onepassword get item id chezmoi secret pass show id chezmoi secret vault -- kv get -format=json id  source [args] #  Execute the source version control system in the source directory with args. Note that any flags for the source version control system must be separated with a -- to stop chezmoi from reading them.\nsource examples #  chezmoi source init chezmoi source add . chezmoi source commit -- -m \u0026quot;Initial commit\u0026quot;  source-path [targets] #  Print the path to each target\u0026rsquo;s source state. If no targets are specified then print the source directory.\nsource-path examples #  chezmoi source-path chezmoi source-path ~/.bashrc  unmanage targets #  unmanage is an alias for forget for symmetry with manage.\nunmanaged #  List all unmanaged files in the destination directory.\nunmanaged examples #  chezmoi unmanaged  update #  Pull changes from the source VCS and apply any changes.\nupdate examples #  chezmoi update  upgrade #  Upgrade chezmoi by downloading and installing the latest released version. This will call the GitHub API to determine if there is a new version of chezmoi available, and if so, download and attempt to install it in the same way as chezmoi was previously installed.\nIf chezmoi was installed with a package manager (dpkg or rpm) then upgrade will download a new package and install it, using sudo if it is installed. Otherwise, chezmoi will download the latest executable and replace the existing executable with the new version.\nIf the CHEZMOI_GITHUB_API_TOKEN environment variable is set, then its value will be used to authenticate requests to the GitHub API, otherwise unauthenticated requests are used which are subject to stricter rate limiting. Unauthenticated requests should be sufficient for most cases.\nupgrade examples #  chezmoi upgrade  verify [targets] #  Verify that all targets match their target state. chezmoi exits with code 0 (success) if all targets match their target state, or 1 (failure) otherwise. If no targets are specified then all targets are checked.\nverify examples #  chezmoi verify chezmoi verify ~/.bashrc  Editor configuration #  The edit and edit-config commands use the editor specified by the VISUAL environment variable, the EDITOR environment variable, or vi, whichever is specified first.\nUmask configuration #  By default, chezmoi uses your current umask as set by your operating system and shell. chezmoi only stores crude permissions in its source state, namely in the executable and private attributes, corresponding to the umasks of 0o111 and 0o077 respectively.\nFor machine-specific control of umask, set the umask configuration variable in chezmoi\u0026rsquo;s configuration file, for example:\numask = 0o22  Template execution #  chezmoi executes templates using text/template. The result is treated differently depending on whether the target is a file or a symlink.\nIf target is a file, then:\n If the result is an empty string, then the file is removed. Otherwise, the target file contents are result.  If the target is a symlink, then:\n Leading and trailing whitespace are stripped from the result. If the result is an empty string, then the symlink is removed. Otherwise, the target symlink target is the result.  chezmoi executes templates using text/template\u0026rsquo;s missingkey=error option, which means that misspelled or missing keys will raise an error. This can be overridden by setting a list of options in the configuration file, for example:\n[template] options = [\u0026quot;missingkey=zero\u0026quot;]  For a full list of options, see Template.Option.\nTemplate variables #  chezmoi provides the following automatically populated variables:\n   Variable Value     .chezmoi.arch Architecture, e.g. amd64, arm, etc. as returned by runtime.GOARCH.   .chezmoi.fullHostname The full hostname of the machine chezmoi is running on.   .chezmoi.group The group of the user running chezmoi.   .chezmoi.homedir The home directory of the user running chezmoi.   .chezmoi.hostname The hostname of the machine chezmoi is running on, up to the first ..   .chezmoi.kernel Contains information from /proc/sys/kernel. Linux only, useful for detecting specific kernels (i.e. Microsoft\u0026rsquo;s WSL kernel).   .chezmoi.os Operating system, e.g. darwin, linux, etc. as returned by runtime.GOOS.   .chezmoi.osRelease The information from /etc/os-release, Linux only, run chezmoi data to see its output.   .chezmoi.sourceDir The source directory.   .chezmoi.username The username of the user running chezmoi.    Additional variables can be defined in the config file in the data section. Variable names must consist of a letter and be followed by zero or more letters and/or digits.\nTemplate functions #  All standard text/template and text template functions from sprig are included. chezmoi provides some additional functions.\nbitwarden [args] #  bitwarden returns structured data retrieved from Bitwarden using the Bitwarden CLI (bw). args are passed to bw unchanged and the output from bw is parsed as JSON. The output from bw is cached so calling bitwarden multiple times with the same arguments will only invoke bw once.\nbitwarden examples #  username = {{ (bitwarden \u0026quot;item\u0026quot; \u0026quot;example.com\u0026quot;).login.username }} password = {{ (bitwarden \u0026quot;item\u0026quot; \u0026quot;example.com\u0026quot;).login.password }}  gopass gopass-name #  gopass returns passwords stored in gopass using the gopass CLI (gopass). gopass-name is passed to gopass show \u0026lt;gopass-name\u0026gt; and first line of the output of gopass is returned with the trailing newline stripped. The output from gopass is cached so calling gopass multiple times with the same gopass-name will only invoke gopass once.\ngopass examples #  {{ gopass \u0026quot;\u0026lt;pass-name\u0026gt;\u0026quot; }}  include filename #  include returns the literal contents of the file named *filename*, relative to the source directory.\njoinPath elements #  joinPath joins any number of path elements into a single path, separating them with the OS-specific path separator. Empty elements are ignored. The result is cleaned. If the argument list is empty or all its elements are empty, joinPath returns an empty string. On Windows, the result will only be a UNC path if the first non-empty element is a UNC path.\njoinPath examples #  {{ joinPath .chezmoi.homedir \u0026quot;.zshrc\u0026quot; }}  keepassxc entry #  keepassxc returns structured data retrieved from a KeePassXC database using the KeePassXC CLI (keepassxc-cli). The database is configured by setting keepassxc.database in the configuration file. database and entry are passed to keepassxc-cli show. You will be prompted for the database password the first time keepassxc-cli is run, and the password is cached, in plain text, in memory until chezmoi terminates. The output from keepassxc-cli is parsed into key-value pairs and cached so calling keepassxc multiple times with the same entry will only invoke keepassxc-cli once.\nkeepassxc examples #  username = {{ (keepassxc \u0026quot;example.com\u0026quot;).UserName }} password = {{ (keepassxc \u0026quot;example.com\u0026quot;).Password }}  keepassxcAttribute entry attribute #  keepassxcAttribute returns the attribute attribute of entry using keepassxc-cli, with any leading or trailing whitespace removed. It behaves identically to the keepassxc function in terms of configuration, password prompting, password storage, and result caching.\nkeepassxcAttribute examples #  {{ keepassxcAttribute \u0026quot;SSH Key\u0026quot; \u0026quot;private-key\u0026quot; }}  lastpass id #  lastpass returns structured data from LastPass using the LastPass CLI (lpass). id is passed to lpass show --json \u0026lt;id\u0026gt; and the output from lpass is parsed as JSON. In addition, the note field, if present, is further parsed as colon-separated key-value pairs. The structured data is an array so typically the index function is used to extract the first item. The output from lastpass is cached so calling lastpass multiple times with the same id will only invoke lpass once.\nlastpass examples #  githubPassword = \u0026quot;{{ (index (lastpass \u0026quot;GitHub\u0026quot;) 0).password }}\u0026quot; {{ (index (lastpass \u0026quot;SSH\u0026quot;) 0).note.privateKey }}  lastpassRaw id #  lastpassRaw returns structured data from LastPass using the LastPass CLI (lpass). It behaves identically to the lastpass function, except that no further parsing is done on the note field.\nlastpassRaw examples #  {{ (index (lastpassRaw \u0026quot;SSH Private Key\u0026quot;) 0).note }}  lookPath file #  lookPath searches for an executable named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. The result may be an absolute path or a path relative to the current directory. If file is not found, lookPath returns an empty string.\nlookPath is not hermetic: its return value depends on the state of the environment and the filesystem at the moment the template is executed. Exercise caution when using it in your templates.\nlookPath examples #  {{ if lookPath \u0026quot;diff-so-fancy\u0026quot; }} # diff-so-fancy is in $PATH {{ end }}  onepassword uuid [vault-uuid] #  onepassword returns structured data from 1Password using the 1Password CLI (op). uuid is passed to op get item \u0026lt;uuid\u0026gt; and the output from op is parsed as JSON. The output from op is cached so calling onepassword multiple times with the same uuid will only invoke op once. If the optional vault-uuid is supplied, it will be passed along to the op get call, which can significantly improve performance.\nonepassword examples #  {{ (onepassword \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot;).details.password }} {{ (onepassword \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; \u0026quot;\u0026lt;vault-uuid\u0026gt;\u0026quot;).details.password }}  onepasswordDocument uuid [vault-uuid] #  onepassword returns a document from 1Password using the 1Password CLI (op). uuid is passed to op get document \u0026lt;uuid\u0026gt; and the output from op is returned. The output from op is cached so calling onepasswordDocument multiple times with the same uuid will only invoke op once. If the optional vault-uuid is supplied, it will be passed along to the op get call, which can significantly improve performance.\nonepasswordDocument examples #  {{- onepasswordDocument \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; -}} {{- onepasswordDocument \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; \u0026quot;\u0026lt;vault-uuid\u0026gt;\u0026quot; -}}  onepasswordDetailsFields uuid [vault-uuid] #  onepasswordDetailsFields returns structured data from 1Password using the 1Password CLI (op). uuid is passed to op get item \u0026lt;uuid\u0026gt;, the output from op is parsed as JSON, and elements of details.fields are returned as a map indexed by each field\u0026rsquo;s designation. For example, give the output from op:\n{ \u0026#34;uuid\u0026#34;: \u0026#34;\u0026lt;uuid\u0026gt;\u0026#34;, \u0026#34;details\u0026#34;: { \u0026#34;fields\u0026#34;: [ { \u0026#34;designation\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;T\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;exampleuser\u0026#34; }, { \u0026#34;designation\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;P\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;examplepassword\u0026#34; } ], } } the return value will be the map:\n{ \u0026#34;username\u0026#34;: { \u0026#34;designation\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;T\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;exampleuser\u0026#34; }, \u0026#34;password\u0026#34;: { \u0026#34;designation\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;P\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;examplepassword\u0026#34; } } The output from op is cached so calling onepassword multiple times with the same uuid will only invoke op once. If the optional vault-uuid is supplied, it will be passed along to the op get call, which can significantly improve performance.\nonepasswordDetailsFields examples #  {{ (onepasswordDetailsFields \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot;).password.value }}  pass pass-name #  pass returns passwords stored in pass using the pass CLI (pass). pass-name is passed to pass show \u0026lt;pass-name\u0026gt; and first line of the output of pass is returned with the trailing newline stripped. The output from pass is cached so calling pass multiple times with the same pass-name will only invoke pass once.\npass examples #  {{ pass \u0026quot;\u0026lt;pass-name\u0026gt;\u0026quot; }}  promptString prompt #  promptString takes a single argument is a string prompted to the user, and the return value is the user\u0026rsquo;s response to that prompt with all leading and trailing space stripped. It is only available when generating the initial config file.\npromptString examples #  {{ $email := promptString \u0026quot;email\u0026quot; -}} [data] email = \u0026quot;{{ $email }}\u0026quot;  secret [args] #  secret returns the output of the generic secret command defined by the genericSecret.command configuration variable with args with leading and trailing whitespace removed. The output is cached so multiple calls to secret with the same args will only invoke the generic secret command once.\nsecretJSON [args] #  secretJSON returns structured data from the generic secret command defined by the genericSecret.command configuration variable with args. The output is parsed as JSON. The output is cached so multiple calls to secret with the same args will only invoke the generic secret command once.\nstat name #  stat runs stat(2) on name. If name exists it returns structured data. If name does not exist then it returns a falsey value. If stat(2) returns any other error then it raises an error. The structured value returned if name exists contains the fields name, size, mode, perm, modTime, and isDir.\nstat is not hermetic: its return value depends on the state of the filesystem at the moment the template is executed. Exercise caution when using it in your templates.\nstat examples #  {{ if stat (joinPath .chezmoi.homedir \u0026quot;.pyenv\u0026quot;) }} # ~/.pyenv exists {{ end }}  vault key #  vault returns structured data from Vault using the Vault CLI (vault). key is passed to vault kv get -format=json \u0026lt;key\u0026gt; and the output from vault is parsed as JSON. The output from vault is cached so calling vault multiple times with the same key will only invoke vault once.\nvault examples #  {{ (vault \u0026quot;\u0026lt;key\u0026gt;\u0026quot;).data.data.password }}  "});})();