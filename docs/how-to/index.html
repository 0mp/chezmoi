<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><meta property="og:title" content="How-To" />
<meta property="og:description" content="How-To Guide Use a hosted repo to manage your dotfiles across multiple machines chezmoi relies on your version control system and hosted repo to share changes across multiple machines. You should create a repo on the source code repository of your choice (e.g. Bitbucket, GitHub, or GitLab, many people call their repo dotfiles) and push the repo in the source directory here. For example:
chezmoi cd git remote add origin https://github." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chezmoi.io/docs/how-to/" />

<title>How-To | chezmoi.io</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.a8b61185b89b0e211122339c7efd1c8edaa4ad4c0ae65f0074e99a4b31c1e393.css" integrity="sha256-qLYRhbibDiERIjOcfv0cjtqkrUwK5l8AdOmaSzHB45M=">


<script defer src="/search.min.d2910896cb283c4abf5f5ff697b56a75be76aac46902527c02ab02f8255ce5c6.js" integrity="sha256-0pEIlssoPEq/X1/2l7Vqdb52qsRpAlJ8AqsC&#43;CVc5cY="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://chezmoi.io/"><img src="/logo-144px.svg" alt="Logo" /><span>chezmoi.io</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    <ul>
<li><a href="/docs/install/">Install</a></li>
<li><a href="/docs/quick-start/">Quick Start</a></li>
<li><a href="/docs/how-to/"class=active>How-To</a></li>
<li><a href="/docs/faq/">FAQ</a></li>
<li><a href="/docs/changes/">Changes</a></li>
<li><a href="/docs/reference/">Reference</a></li>
<li><a href="/docs/media/">Media</a></li>
<li><a href="/docs/contributing/">Contributing</a></li>
<li><a href="https://github.com/twpayne/chezmoi">GitHub</a></li>
</ul>





</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>How-To</strong>
</header>

      
<article class="markdown"><h1 id="how-to-guide">How-To Guide</h1>
<h2 id="use-a-hosted-repo-to-manage-your-dotfiles-across-multiple-machines">Use a hosted repo to manage your dotfiles across multiple machines</h2>
<p>chezmoi relies on your version control system and hosted repo to share changes
across multiple machines. You should create a repo on the source code repository
of your choice (e.g. <a href="https://bitbucket.org">Bitbucket</a>,
<a href="https://github.com/">GitHub</a>, or <a href="https://gitlab.com">GitLab</a>, many people call
their repo <code>dotfiles</code>) and push the repo in the source directory here. For
example:</p>
<pre><code>chezmoi cd
git remote add origin https://github.com/username/dotfiles.git
git push -u origin master
exit
</code></pre>
<p>On another machine you can checkout this repo:</p>
<pre><code>chezmoi init https://github.com/username/dotfiles.git
</code></pre>
<p>You can then see what would be changed:</p>
<pre><code>chezmoi diff
</code></pre>
<p>If you&rsquo;re happy with the changes then apply them:</p>
<pre><code>chezmoi apply
</code></pre>
<p>The above commands can be combined into a single init, checkout, and apply:</p>
<pre><code>chezmoi init --apply --verbose https://github.com/username/dotfiles.git
</code></pre>
<h2 id="pull-the-latest-changes-from-your-repo-and-apply-them">Pull the latest changes from your repo and apply them</h2>
<p>You can pull the changes from your repo and apply them in a single command:</p>
<pre><code>chezmoi update
</code></pre>
<p>This runs <code>git pull --rebase</code> in your source directory and then <code>chezmoi apply</code>.</p>
<h2 id="pull-the-latest-changes-from-your-repo-and-see-what-would-change-without-actually-applying-the-changes">Pull the latest changes from your repo and see what would change, without actually applying the changes</h2>
<p>Run:</p>
<pre><code>chezmoi source pull -- --rebase &amp;&amp; chezmoi diff
</code></pre>
<p>This runs <code>git pull --rebase</code> in your source directory and <code>chezmoi diff</code> then shows the difference between the target state computed from your
source directory and the actual state.</p>
<p>If you&rsquo;re happy with the changes, then you can run</p>
<pre><code>chezmoi apply
</code></pre>
<p>to apply them.</p>
<h2 id="automatically-commit-and-push-changes-to-your-repo">Automatically commit and push changes to your repo</h2>
<p>chezmoi can automatically commit and push changes to your source directory to
your repo. This feature is disabled by default. To enable it, add the following
to your config file:</p>
<pre><code>[sourceVCS]
    autoCommit = true
    autoPush = true
</code></pre>
<p>Whenever a change is made to your source directory, chezmoi will commit the
changes with an automatically-generated commit message (if <code>autoCommit</code> is true)
and push them to your repo (if <code>autoPush</code> is true). <code>autoPush</code> implies
<code>autoCommit</code>, i.e. if <code>autoPush</code> is true then chezmoi will auto-commit your
changes. If you only set <code>autoCommit</code> to true then changes will be committed but
not pushed.</p>
<p>Be careful when using <code>autoPush</code>. If your dotfiles repo is public and you
accidentally add a secret in plain text, that secret will be pushed to your
public repo.</p>
<h2 id="use-templates-to-manage-files-that-vary-from-machine-to-machine">Use templates to manage files that vary from machine to machine</h2>
<p>The primary goal of chezmoi is to manage configuration files across multiple
machines, for example your personal macOS laptop, your work Ubuntu desktop, and
your work Linux laptop. You will want to keep much configuration the same across
these, but also need machine-specific configurations for email addresses,
credentials, etc. chezmoi achieves this functionality by using
<a href="https://pkg.go.dev/text/template"><code>text/template</code></a> for the source state where
needed.</p>
<p>For example, your home <code>~/.gitconfig</code> on your personal machine might look like:</p>
<pre><code>[user]
  email = &quot;john@home.org&quot;
</code></pre>
<p>Whereas at work it might be:</p>
<pre><code>[user]
  email = &quot;john.smith@company.com&quot;
</code></pre>
<p>To handle this, on each machine create a configuration file called
<code>~/.config/chezmoi/chezmoi.toml</code> defining variables that might vary from machine
to machine. For example, for your home machine:</p>
<pre><code>[data]
  email = &quot;john@home.org&quot;
</code></pre>
<p>Note that all variable names will be converted to lowercase. This is due to a
feature of a library used by chezmoi.</p>
<p>If you intend to store private data (e.g. access tokens) in
<code>~/.config/chezmoi/chezmoi.toml</code>, make sure it has permissions <code>0600</code>.</p>
<p>If you prefer, you can use any format supported by
<a href="https://github.com/spf13/viper">Viper</a> for your configuration file. This
includes JSON, YAML, and TOML. Variable names must start with a letter and be
followed by zero or more letters or digits.</p>
<p>Then, add <code>~/.gitconfig</code> to chezmoi using the <code>--autotemplate</code> flag to turn it
into a template and automatically detect variables from the <code>data</code> section
of your <code>~/.config/chezmoi/chezmoi.toml</code> file:</p>
<pre><code>chezmoi add --autotemplate ~/.gitconfig
</code></pre>
<p>You can then open the template (which will be saved in the file
<code>~/.local/share/chezmoi/dot_gitconfig.tmpl</code>):</p>
<pre><code>chezmoi edit ~/.gitconfig
</code></pre>
<p>The file should look something like:</p>
<pre><code>[user]
  email = &quot;{{ .email }}&quot;
</code></pre>
<p>To disable automatic variable detection, use the <code>--template</code> or <code>-T</code> option to
<code>chezmoi add</code> instead of <code>--autotemplate</code>.</p>
<p>Templates are often used to capture machine-specific differences. For example,
in your <code>~/.local/share/chezmoi/dot_bashrc.tmpl</code> you might have:</p>
<pre><code># common config
export EDITOR=vi

# machine-specific configuration
{{- if eq .chezmoi.hostname &quot;work-laptop&quot; }}
# this will only be included in ~/.bashrc on work-laptop
{{- end }}
</code></pre>
<p>For a full list of variables, run:</p>
<pre><code>chezmoi data
</code></pre>
<p>For more advanced usage, you can use the full power of the
<a href="https://pkg.go.dev/text/template"><code>text/template</code></a> language. chezmoi includes
all of the text functions from <a href="http://masterminds.github.io/sprig/">sprig</a> and
its own <a href="/docs/reference/#template-functions">functions for interacting with password
managers</a>.</p>
<p>Templates can be executed directly from the command line, without the need to
create a file on disk, with the <code>execute-template</code> command, for example:</p>
<pre><code>chezmoi execute-template '{{ .chezmoi.os }}/{{ .chezmoi.arch }}'
</code></pre>
<p>This is useful when developing or debugging templates.</p>
<p>Some password managers allow you to store complete files. The files can be
retrieved with chezmoi&rsquo;s template functions. For example, if you have a file
stored in 1Password with the UUID <code>uuid</code> then you can retrieve it with the
template:</p>
<pre><code>{{- onepasswordDocument &quot;uuid&quot; -}}
</code></pre>
<p>The <code>-</code>s inside the brackets remove any whitespace before or after the template
expression, which is useful if your editor has added any newlines.</p>
<p>If, after executing the template, the file contents are empty, the target file
will be removed. This can be used to ensure that files are only present on
certain machines. If you want an empty file to be created anyway, you will need
to give it an <code>empty_</code> prefix.</p>
<p>For coarser-grained control of files and entire directories managed on different
machines, or to exclude certain files completely, you can create
<code>.chezmoiignore</code> files in the source directory. These specify a list of patterns
that chezmoi should ignore, and are interpreted as templates. An example
<code>.chezmoiignore</code> file might look like:</p>
<pre><code>README.md
{{- if ne .chezmoi.hostname &quot;work-laptop&quot; }}
.work # only manage .work on work-laptop
{{- end }}
</code></pre>
<p>The use of <code>ne</code> (not equal) is deliberate. What we want to achieve is &ldquo;only
install <code>.work</code> if hostname is <code>work-laptop</code>&rdquo; but chezmoi installs everything by
default, so we have to turn the logic around and instead write &ldquo;ignore <code>.work</code>
unless the hostname is <code>work-laptop</code>&rdquo;.</p>
<p>Patterns can be excluded by prefixing them with a <code>!</code>, for example:</p>
<pre><code>f*
!foo
</code></pre>
<p>will ignore all files beginning with an <code>f</code> except <code>foo</code>.</p>
<h2 id="use-completely-separate-config-files-on-different-machines">Use completely separate config files on different machines</h2>
<p>chezmoi&rsquo;s template functionality allows you to change a file&rsquo;s contents based on
any variable. For example, if you want <code>~/.bashrc</code> to be different on Linux and
macOS you would create a file in the source state called <code>dot_bashrc.tmpl</code>
containing:</p>
<pre><code>{{ if eq .chezmoi.os &quot;darwin&quot; -}}
# macOS .bashrc contents
{{ else if eq .chezmoi.os &quot;linux&quot; -}}
# Linux .bashrc contents
{{ end -}}
</code></pre><p>However, if the differences between the two versions are so large that you&rsquo;d
prefer to use completely separate files in the source state, you can achieve
this using a symbolic link template. Create the following files:</p>
<p><code>symlink_dot_bashrc.tmpl</code>:</p>
<pre><code>.bashrc_{{ .chezmoi.os }}
</code></pre><p><code>dot_bashrc_darwin</code>:</p>
<pre><code># macOS .bashrc contents
</code></pre><p><code>dot_bashrc_linux</code>:</p>
<pre><code># Linux .bashrc contents
</code></pre><p><code>.chezmoiignore</code></p>
<pre><code>{{ if ne .chezmoi.os &quot;darwin&quot; }}
.bashrc_darwin
{{ end }}
{{ if ne .chezmoi.os &quot;linux&quot; }}
.bashrc_linux
{{ end }}
</code></pre><p>This will make <code>~/.bashrc</code> will be a symlink to <code>.bashrc_darwin</code> on <code>darwin</code> and
to <code>.bashrc_linux</code>. The <code>.chezmoiignore</code> configuration ensures that only the
OS-specific <code>.bashrc_os</code> file will be installed on each OS.</p>
<h2 id="create-a-config-file-on-a-new-machine-automatically">Create a config file on a new machine automatically</h2>
<p><code>chezmoi init</code> can also create a config file automatically, if one does not
already exist. If your repo contains a file called <code>.chezmoi.&lt;format&gt;.tmpl</code>
where <em>format</em> is one of the supported config file formats (e.g. <code>json</code>, <code>toml</code>,
or <code>yaml</code>) then <code>chezmoi init</code> will execute that template to generate your
initial config file.</p>
<p>Specifically, if you have <code>.chezmoi.toml.tmpl</code> that looks like this:</p>
<pre><code>{{- $email := promptString &quot;email&quot; -}}
[data]
    email = &quot;{{ $email }}&quot;
</code></pre>
<p>Then <code>chezmoi init</code> will create an initial <code>chezmoi.toml</code> using this template.
<code>promptString</code> is a special function that prompts the user (you) for a value.</p>
<p>To test this template, use <code>chezmoi execute-template</code> with the <code>--init</code> and
<code>--promptString</code> flags, for example:</p>
<pre><code>chezmoi execute-template --init --promptString email=john@home.org &lt; ~/.local/share/chezmoi/.chezmoi.toml.tmpl
</code></pre>
<h2 id="have-chezmoi-create-a-directory-but-ignore-its-contents">Have chezmoi create a directory, but ignore its contents</h2>
<p>If you want chezmoi to create a directory, but ignore its contents, say <code>~/src</code>,
first run:</p>
<pre><code>mkdir -p $(chezmoi source-path)/src
</code></pre>
<p>This creates the directory in the source state, which means that chezmoi will
create it (if it does not already exist) when you run <code>chezmoi apply</code>.</p>
<p>However, as this is an empty directory it will be ignored by git. So, create a
file in the directory in the source state that will be seen by git (so git does
not ignore the directory) but ignored by chezmoi (so chezmoi does not include it
in the target state):</p>
<pre><code>touch $(chezmoi source-path)/src/.keep
</code></pre>
<p>chezmoi automatically creates <code>.keep</code> files when you add an empty directory with
<code>chezmoi add</code>.</p>
<h2 id="ensure-that-a-target-is-removed">Ensure that a target is removed</h2>
<p>Create a file called <code>.chezmoiremove</code> in the source directory containing a list
of patterns of files to remove. When you run</p>
<pre><code>chezmoi apply --remove
</code></pre>
<p>chezmoi will remove anything in the target directory that matches the pattern.
As this command is potentially dangerous, you should run chezmoi in verbose,
dry-run mode beforehand to see what would be removed:</p>
<pre><code>chezmoi apply --remove --dry-run --verbose
</code></pre>
<p><code>.chezmoiremove</code> is interpreted as a template, so you can remove different files
on different machines. Negative matches (patterns prefixed with a <code>!</code>) or
targets listed in <code>.chezmoiignore</code> will never be removed.</p>
<h2 id="include-a-subdirectory-from-another-repository-like-oh-my-zsh">Include a subdirectory from another repository, like Oh My Zsh</h2>
<p>To include a subdirectory from another repository, e.g. <a href="https://github.com/robbyrussell/oh-my-zsh">Oh My
Zsh</a>, you cannot use git submodules
because chezmoi uses its own format for the source state and Oh My Zsh is not
distributed in this format. Instead, you can use the <code>import</code> command to import
a snapshot from a tarball:</p>
<pre><code>curl -s -L -o oh-my-zsh-master.tar.gz https://github.com/robbyrussell/oh-my-zsh/archive/master.tar.gz
chezmoi import --strip-components 1 --destination ${HOME}/.oh-my-zsh oh-my-zsh-master.tar.gz
</code></pre>
<p>Add <code>oh-my-zsh-master.tar.gz</code> to <code>.chezmoiignore</code> if you run these commands in
your source directory so that chezmoi doesn&rsquo;t try to copy the tarball anywhere.</p>
<p>Disable Oh My Zsh auto-updates by setting <code>DISABLE_AUTO_UPDATE=&quot;true&quot;</code> in
<code>~/.zshrc</code>. Auto updates will cause the <code>~/.oh-my-zsh</code> directory to drift out of
sync with chezmoi&rsquo;s source state. To update Oh My Zsh, re-run the <code>curl</code> and
<code>chezmoi import</code> commands above.</p>
<h2 id="handle-configuration-files-which-are-externally-modified">Handle configuration files which are externally modified</h2>
<p>Some programs modify their configuration files. When you next run <code>chezmoi apply</code>, any modifications made by the program will be lost.</p>
<p>You can track changes to these files by replacing with a symlink back to a file
in your source directory, which is under version control. Here is a worked
example for VSCode&rsquo;s <code>settings.json</code> on Linux:</p>
<p>Copy the configuration file to your source directory:</p>
<pre><code>cp ~/.config/Code/User/settings.json $(chezmoi source-path)
</code></pre>
<p>Tell chezmoi to ignore this file:</p>
<pre><code>echo settings.json &gt;&gt; $(chezmoi source-path)/.chezmoiignore
</code></pre>
<p>Tell chezmoi that <code>~/.config/Code/User/settings.json</code> should be a symlink to the
file in your source directory:</p>
<pre><code>mkdir -p $(chezmoi source-path)/private_dot_config/private_Code/User
echo -n &quot;{{ .chezmoi.sourceDir }}/settings.json&quot; &gt; $(chezmoi source-path)/private_dot_config/private_Code/User/symlink_settings.json.tmpl
</code></pre>
<p>The prefix <code>private_</code> is used because the <code>~/.config</code> and <code>~/.config/Code</code>
directories are private by default.</p>
<p>Apply the changes:</p>
<pre><code>chezmoi apply -v
</code></pre>
<p>Now, when the program modifies its configuration file it will modify the file in
the source state instead.</p>
<h2 id="keep-data-private">Keep data private</h2>
<p>chezmoi automatically detects when files and directories are private when adding
them by inspecting their permissions. Private files and directories are stored
in <code>~/.local/share/chezmoi</code> as regular, public files with permissions <code>0644</code> and
the name prefix <code>private_</code>. For example:</p>
<pre><code>chezmoi add ~/.netrc
</code></pre>
<p>will create <code>~/.local/share/chezmoi/private_dot_netrc</code> (assuming <code>~/.netrc</code> is
not world- or group- readable, as it should be). This file is still private
because <code>~/.local/share/chezmoi</code> is not group- or world- readable or executable.
chezmoi checks that the permissions of <code>~/.local/share/chezmoi</code> are <code>0700</code> on
every run and will print a warning if they are not.</p>
<p>It is common that you need to store access tokens in config files, e.g. a
<a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/">GitHub access
token</a>.
There are several ways to keep these tokens secure, and to prevent them leaving
your machine.</p>
<h3 id="use-bitwarden-to-keep-your-secrets">Use Bitwarden to keep your secrets</h3>
<p>chezmoi includes support for <a href="https://bitwarden.com/">Bitwarden</a> using the
<a href="https://github.com/bitwarden/cli">Bitwarden CLI</a> to expose data as a template
function.</p>
<p>Log in to Bitwarden using:</p>
<pre><code>bw login &lt;bitwarden-email&gt;
</code></pre>
<p>Unlock your Bitwarden vault:</p>
<pre><code>bw unlock
</code></pre>
<p>Set the <code>BW_SESSION</code> environment variable, as instructed.</p>
<p>The structured data from <code>bw get</code> is available as the <code>bitwarden</code> template
function in your config files, for example:</p>
<pre><code>username = {{ (bitwarden &quot;item&quot; &quot;example.com&quot;).login.username }}
password = {{ (bitwarden &quot;item&quot; &quot;example.com&quot;).login.password }}
</code></pre>
<h3 id="use-gopass-to-keep-your-secrets">Use gopass to keep your secrets</h3>
<p>chezmoi includes support for <a href="https://www.gopass.pw/">gopass</a> using the gopass CLI.</p>
<p>The first line of the output of <code>gopass show &lt;pass-name&gt;</code> is available as the
<code>gopass</code> template function, for example:</p>
<pre><code>{{ gopass &quot;&lt;pass-name&gt;&quot; }}
</code></pre>
<h3 id="use-gpg-to-keep-your-secrets">Use gpg to keep your secrets</h3>
<p>chezmoi supports encrypting files with <a href="https://www.gnupg.org/">gpg</a>. Encrypted
files are stored in the source state and automatically be decrypted when
generating the target state or printing a file&rsquo;s contents with <code>chezmoi cat</code>.
<code>chezmoi edit</code> will transparently decrypt the file before editing and re-encrypt
it afterwards.</p>
<h4 id="asymmetric-privatepublic-key-encryption">Asymmetric (private/public-key) encryption</h4>
<p>Specify the encryption key to use in your configuration file (<code>chezmoi.toml</code>)
with the <code>gpg.recipient</code> key:</p>
<pre><code>[gpg]
  recipient = &quot;...&quot;
</code></pre>
<p>Add files to be encrypted with the <code>--encrypt</code> flag, for example:</p>
<pre><code>chezmoi add --encrypt ~/.ssh/id_rsa
</code></pre>
<p>chezmoi will encrypt the file with:</p>
<pre><code>gpg --armor --recipient ${gpg.recipient} --encrypt
</code></pre>
<p>and store the encrypted file in the source state. The file will automatically be
decrypted when generating the target state.</p>
<h4 id="symmetric-encryption">Symmetric encryption</h4>
<p>Specify symmetric encryption in your configuration file:</p>
<pre><code>[gpg]
  symmetric = true
</code></pre>
<p>Add files to be encrypted with the <code>--encrypt</code> flag, for example:</p>
<pre><code>chezmoi add --encrypt ~/.ssh/id_rsa
</code></pre>
<p>chezmoi will encrypt the file with:</p>
<pre><code>gpg --armor --symmetric
</code></pre>
<h3 id="use-keepassxc-to-keep-your-secrets">Use KeePassXC to keep your secrets</h3>
<p>chezmoi includes support for <a href="https://keepassxc.org">KeePassXC</a> using the
KeePassXC CLI (<code>keepassxc-cli</code>) to expose data as a template function.</p>
<p>Provide the path to your KeePassXC database in your configuration file:</p>
<pre><code>[keepassxc]
  database = &quot;/home/user/Passwords.kdbx&quot;
</code></pre>
<p>The structured data from <code>keepassxc-cli show $database</code> is available as the
<code>keepassxc</code> template function in your config files, for example:</p>
<pre><code>username = {{ (keepassxc &quot;example.com&quot;).UserName }}
password = {{ (keepassxc &quot;example.com&quot;).Password }}
</code></pre>
<p>Additional attributes are available through the <code>keepassxcAttribute</code> function.
For example, if you have an entry called <code>SSH Key</code> with an additional attribute
called <code>private-key</code>, its value is available as:</p>
<pre><code>{{ keepassxcAttribute &quot;SSH Key&quot; &quot;private-key&quot; }}
</code></pre>
<h3 id="use-a-keyring-to-keep-your-secrets">Use a keyring to keep your secrets</h3>
<p>chezmoi includes support for Keychain (on macOS), GNOME Keyring (on Linux), and
Windows Credentials Manager (on Windows) via the
<a href="https://github.com/zalando/go-keyring"><code>zalando/go-keyring</code></a> library.</p>
<p>Set passwords with:</p>
<pre><code>$ chezmoi keyring set --service=&lt;service&gt; --user=&lt;user&gt;
Password: xxxxxxxx
</code></pre>
<p>The password can then be used in templates using the <code>keyring</code> function which
takes the service and user as arguments.</p>
<p>For example, save a GitHub access token in keyring with:</p>
<pre><code>$ chezmoi keyring set --service=github --user=&lt;github-username&gt;
Password: xxxxxxxx
</code></pre>
<p>and then include it in your <code>~/.gitconfig</code> file with:</p>
<pre><code>[github]
  user = &quot;{{ .github.user }}&quot;
  token = &quot;{{ keyring &quot;github&quot; .github.user }}&quot;
</code></pre>
<p>You can query the keyring from the command line:</p>
<pre><code>chezmoi keyring get --service=github --user=&lt;github-username&gt;
</code></pre>
<h3 id="use-lastpass-to-keep-your-secrets">Use LastPass to keep your secrets</h3>
<p>chezmoi includes support for <a href="https://lastpass.com">LastPass</a> using the
<a href="https://lastpass.github.io/lastpass-cli/lpass.1.html">LastPass CLI</a> to expose
data as a template function.</p>
<p>Log in to LastPass using:</p>
<pre><code>lpass login &lt;lastpass-username&gt;
</code></pre>
<p>Check that <code>lpass</code> is working correctly by showing password data:</p>
<pre><code>lpass show --json &lt;lastpass-entry-id&gt;
</code></pre>
<p>where <code>&lt;lastpass-entry-id&gt;</code> is a <a href="https://lastpass.github.io/lastpass-cli/lpass.1.html#_entry_specification">LastPass Entry
Specification</a>.</p>
<p>The structured data from <code>lpass show --json id</code> is available as the <code>lastpass</code>
template function. The value will be an array of objects. You can use the
<code>index</code> function and <code>.Field</code> syntax of the <code>text/template</code> language to extract
the field you want. For example, to extract the <code>password</code> field from first the
&ldquo;GitHub&rdquo; entry, use:</p>
<pre><code>githubPassword = &quot;{{ (index (lastpass &quot;GitHub&quot;) 0).password }}&quot;
</code></pre>
<p>chezmoi automatically parses the <code>note</code> value of the Lastpass entry as
colon-separated key-value pairs, so, for example, you can extract a private SSH
key like this:</p>
<pre><code>{{ (index (lastpass &quot;SSH&quot;) 0).note.privateKey }}
</code></pre>
<p>Keys in the <code>note</code> section written as <code>CamelCase Words</code> are converted to
<code>camelCaseWords</code>.</p>
<p>If the <code>note</code> value does not contain colon-separated key-value pairs, then you
can use <code>lastpassRaw</code> to get its raw value, for example:</p>
<pre><code>{{ (index (lastpassRaw &quot;SSH Private Key&quot;) 0).note }}
</code></pre>
<h3 id="use-1password-to-keep-your-secrets">Use 1Password to keep your secrets</h3>
<p>chezmoi includes support for <a href="https://1password.com/">1Password</a> using the
<a href="https://support.1password.com/command-line-getting-started/">1Password CLI</a> to
expose data as a template function.</p>
<p>Log in and get a session using:</p>
<pre><code>eval $(op signin &lt;subdomain&gt;.1password.com &lt;email&gt;)
</code></pre>
<p>The output of <code>op get item &lt;uuid&gt;</code> is available as the <code>onepassword</code> template
function. chezmoi parses the JSON output and returns it as structured data. For
example, if the output of <code>op get item &quot;&lt;uuid&gt;&quot;</code> is:</p>
<pre><code>{
    &quot;uuid&quot;: &quot;&lt;uuid&gt;&quot;,
    &quot;details&quot;: {
        &quot;password&quot;: &quot;xxx&quot;
    }
}
</code></pre>
<p>Then you can access <code>details.password</code> with the syntax:</p>
<pre><code>{{ (onepassword &quot;&lt;uuid&gt;&quot;).details.password }}
</code></pre>
<p>Documents can be retrieved with:</p>
<pre><code>{{- onepasswordDocument &quot;uuid&quot; -}}
</code></pre>
<p>Note the extra <code>-</code> after the opening <code>{{</code> and before the closing <code>}}</code>. This
instructs the template language to remove and whitespace before and after the
substitution. This removes any trailing newline added by your editor when saving
the template.</p>
<h3 id="use-pass-to-keep-your-secrets">Use pass to keep your secrets</h3>
<p>chezmoi includes support for <a href="https://www.passwordstore.org/">pass</a> using the
pass CLI.</p>
<p>The first line of the output of <code>pass show &lt;pass-name&gt;</code> is available as the
<code>pass</code> template function, for example:</p>
<pre><code>{{ pass &quot;&lt;pass-name&gt;&quot; }}
</code></pre>
<h3 id="use-vault-to-keep-your-secrets">Use Vault to keep your secrets</h3>
<p>chezmoi includes support for <a href="https://www.vaultproject.io/">Vault</a> using the
<a href="https://www.vaultproject.io/docs/commands/">Vault CLI</a> to expose data as a
template function.</p>
<p>The vault CLI needs to be correctly configured on your machine, e.g. the
<code>VAULT_ADDR</code> and <code>VAULT_TOKEN</code> environment variables must be set correctly.
Verify that this is the case by running:</p>
<pre><code>vault kv get -format=json &lt;key&gt;
</code></pre>
<p>The structured data from <code>vault kv get -format=json</code> is available as the <code>vault</code>
template function. You can use the <code>.Field</code> syntax of the <code>text/template</code>
language to extract the data you want. For example:</p>
<pre><code>{{ (vault &quot;&lt;key&gt;&quot;).data.data.password }}
</code></pre>
<h3 id="use-a-generic-tool-to-keep-your-secrets">Use a generic tool to keep your secrets</h3>
<p>You can use any command line tool that outputs secrets either as a string or in
JSON format. Choose the binary by setting <code>genericSecret.command</code> in your
configuration file. You can then invoke this command with the <code>secret</code> and
<code>secretJSON</code> template functions which return the raw output and JSON-decoded
output respectively. All of the above secret managers can be supported in this
way:</p>
<table>
<thead>
<tr>
<th>Secret Manager</th>
<th><code>genericSecret.command</code></th>
<th>Template skeleton</th>
</tr>
</thead>
<tbody>
<tr>
<td>1Password</td>
<td><code>op</code></td>
<td><code>{{ secretJSON &quot;get&quot; &quot;item&quot; &lt;id&gt; }}</code></td>
</tr>
<tr>
<td>Bitwarden</td>
<td><code>bw</code></td>
<td><code>{{ secretJSON &quot;get&quot; &lt;id&gt; }}</code></td>
</tr>
<tr>
<td>Hashicorp Vault</td>
<td><code>vault</code></td>
<td><code>{{ secretJSON &quot;kv&quot; &quot;get&quot; &quot;-format=json&quot; &lt;id&gt; }}</code></td>
</tr>
<tr>
<td>LastPass</td>
<td><code>lpass</code></td>
<td><code>{{ secretJSON &quot;show&quot; &quot;--json&quot; &lt;id&gt; }}</code></td>
</tr>
<tr>
<td>KeePassXC</td>
<td><code>keepassxc-cli</code></td>
<td>Not possible (interactive command only)</td>
</tr>
<tr>
<td>pass</td>
<td><code>pass</code></td>
<td><code>{{ secret &quot;show&quot; &lt;id&gt; }}</code></td>
</tr>
</tbody>
</table>
<h3 id="use-templates-variables-to-keep-your-secrets">Use templates variables to keep your secrets</h3>
<p>Typically, <code>~/.config/chezmoi/chezmoi.toml</code> is not checked in to version control
and has permissions 0600. You can store tokens as template values in the <code>data</code>
section. For example, if your <code>~/.config/chezmoi/chezmoi.toml</code> contains:</p>
<pre><code>[data]
  [data.github]
    user = &quot;&lt;github-username&gt;&quot;
    token = &quot;&lt;github-token&gt;&quot;
</code></pre>
<p>Your <code>~/.local/share/chezmoi/private_dot_gitconfig.tmpl</code> can then contain:</p>
<pre><code>{{- if (index . &quot;github&quot;) }}
[github]
  user = &quot;{{ .github.user }}&quot;
  token = &quot;{{ .github.token }}&quot;
{{- end }}
</code></pre>
<p>Any config files containing tokens in plain text should be private (permissions
<code>0600</code>).</p>
<h2 id="use-scripts-to-perform-actions">Use scripts to perform actions</h2>
<h3 id="understand-how-scripts-work">Understand how scripts work</h3>
<p>chezmoi supports scripts, which are executed when you run <code>chezmoi apply</code>. The
scripts can either run every time you run <code>chezmoi apply</code>, or only when their
contents have changed.</p>
<p>In verbose mode, the script&rsquo;s contents will be printed before executing it. In
dry-run mode, the script is not executed.</p>
<p>Scripts are any file in the source directory with the prefix <code>run_</code>, and are
executed in alphabetical order. Scripts that should only be run when their
contents change have the prefix <code>run_once_</code>.</p>
<p>Scripts break chezmoi&rsquo;s declarative approach, and as such should be used
sparingly. Any script should be idempotent, even <code>run_once_</code> scripts.</p>
<p>Scripts must be created manually in the source directory, typically by running
<code>chezmoi cd</code> and then creating a file with a <code>run_</code> prefix. Scripts are executed
directly using <code>exec</code> and must include a shebang line or be executable binaries.
There is no need to set the executable bit on the script.</p>
<p>Scripts with the suffix <code>.tmpl</code> are treated as templates, with the usual
template variables available. If, after executing the template, the result is
only whitespace or an empty string, then the script is not executed. This is
useful for disabling scripts.</p>
<h3 id="install-packages-with-scripts">Install packages with scripts</h3>
<p>Change to the source directory and create a file called
<code>run_once_install-packages.sh</code>:</p>
<pre><code>chezmoi cd
$EDITOR run_once_install-packages.sh
</code></pre>
<p>In this file create your package installation script, e.g.</p>
<pre><code>#!/bin/sh
sudo apt install ripgrep
</code></pre>
<p>The next time you run <code>chezmoi apply</code> or <code>chezmoi update</code> this script will be
run. As it has the <code>run_once_</code> prefix, it will not be run again unless its
contents change, for example if you add more packages to be installed.</p>
<p>This script can also be a template. For example, if you create
<code>run_once_install-packages.sh.tmpl</code> with the contents:</p>
<pre><code>{{ if eq .chezmoi.os &quot;linux&quot; -}}
#!/bin/sh
sudo apt install ripgrep
{{ else if eq .chezmoi.os &quot;darwin&quot; -}}
#!/bin/sh
brew install ripgrep
{{ end -}}
</code></pre>
<p>This will install <code>ripgrep</code> on both Debian/Ubuntu Linux systems and macOS.</p>
<h2 id="import-archives">Import archives</h2>
<p>It is occasionally useful to import entire archives of configuration into your
source state. The <code>import</code> command does this. For example, to import the latest
version
<a href="https://github.com/robbyrussell/oh-my-zsh"><code>github.com/robbyrussell/oh-my-zsh</code></a>
to <code>~/.oh-my-zsh</code> run:</p>
<pre><code>curl -s -L -o oh-my-zsh-master.tar.gz https://github.com/robbyrussell/oh-my-zsh/archive/master.tar.gz
chezmoi import --strip-components 1 --destination ~/.oh-my-zsh oh-my-zsh-master.tar.gz
</code></pre>
<p>Note that this only updates the source state. You will need to run</p>
<pre><code>chezmoi apply
</code></pre>
<p>to update your destination directory.</p>
<h2 id="export-archives">Export archives</h2>
<p>chezmoi can create an archive containing the target state. This can be useful
for generating target state on a different machine or for simply inspecting the
target state. A particularly useful command is:</p>
<pre><code>chezmoi archive | tar tvf -
</code></pre>
<p>which lists all the targets in the target state.</p>
<h2 id="use-a-non-git-version-control-system">Use a non-git version control system</h2>
<p>By default, chezmoi uses git, but you can use any version control system of your
choice. In your config file, specify the command to use. For example, to use
Mercurial specify:</p>
<pre><code>[sourceVCS]
  command = &quot;hg&quot;
</code></pre>
<p>The source VCS command is used in the chezmoi commands <code>init</code>, <code>source</code>, and
<code>update</code>, and support for VCSes other than git is limited but easy to add. If
you&rsquo;d like to see your VCS better supported, please <a href="https://github.com/twpayne/chezmoi/issues/new/choose">open an issue on
GitHub</a>.</p>
<h2 id="customize-the-diff-command">Customize the <code>diff</code> command</h2>
<p>By default, chezmoi uses a built-in diff. You can change the format, and/or pipe
the output into a pager of your choice. For example, to use
<a href="https://github.com/so-fancy/diff-so-fancy"><code>diff-so-fancy</code></a> specify:</p>
<pre><code>[diff]
    format = &quot;git&quot;
    pager = &quot;diff-so-fancy&quot;
</code></pre>
<p>The format can also be set with the <code>--format</code> option to the <code>diff</code> command, and
the pager can be disabled using <code>--no-pager</code>.</p>
<h2 id="use-a-merge-tool-other-than-vimdiff">Use a merge tool other than vimdiff</h2>
<p>By default, chezmoi uses vimdiff, but you can use any merge tool of your choice.
In your config file, specify the command and args to use. For example, to use
neovim&rsquo;s diff mode specify:</p>
<pre><code>[merge]
  command = &quot;nvim&quot;
  args = &quot;-d&quot;
</code></pre>
<h2 id="migrate-from-a-dotfile-manager-that-uses-symlinks">Migrate from a dotfile manager that uses symlinks</h2>
<p>Many dotfile managers replace dotfiles with symbolic links to files in a common
directory. If you <code>chezmoi add</code> such a symlink, chezmoi will add the symlink,
not the file. To assist with migrating from symlink-based systems, use the
<code>--follow</code> option to <code>chezmoi add</code>, for example:</p>
<pre><code>chezmoi add --follow ~/.bashrc
</code></pre>
<p>This will tell <code>chezmoi add</code> that the target state of <code>~/.bashrc</code> is the target
of the <code>~/.bashrc</code> symlink, rather than the symlink itself. When you run
<code>chezmoi apply</code>, chezmoi will replace the <code>~/.bashrc</code> symlink with the file
contents.</p>
</article>

      

      
    </div>

    
  

  <aside class="book-toc levels-3 fixed">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#use-a-hosted-repo-to-manage-your-dotfiles-across-multiple-machines">Use a hosted repo to manage your dotfiles across multiple machines</a></li>
    <li><a href="#pull-the-latest-changes-from-your-repo-and-apply-them">Pull the latest changes from your repo and apply them</a></li>
    <li><a href="#pull-the-latest-changes-from-your-repo-and-see-what-would-change-without-actually-applying-the-changes">Pull the latest changes from your repo and see what would change, without actually applying the changes</a></li>
    <li><a href="#automatically-commit-and-push-changes-to-your-repo">Automatically commit and push changes to your repo</a></li>
    <li><a href="#use-templates-to-manage-files-that-vary-from-machine-to-machine">Use templates to manage files that vary from machine to machine</a></li>
    <li><a href="#use-completely-separate-config-files-on-different-machines">Use completely separate config files on different machines</a></li>
    <li><a href="#create-a-config-file-on-a-new-machine-automatically">Create a config file on a new machine automatically</a></li>
    <li><a href="#have-chezmoi-create-a-directory-but-ignore-its-contents">Have chezmoi create a directory, but ignore its contents</a></li>
    <li><a href="#ensure-that-a-target-is-removed">Ensure that a target is removed</a></li>
    <li><a href="#include-a-subdirectory-from-another-repository-like-oh-my-zsh">Include a subdirectory from another repository, like Oh My Zsh</a></li>
    <li><a href="#handle-configuration-files-which-are-externally-modified">Handle configuration files which are externally modified</a></li>
    <li><a href="#keep-data-private">Keep data private</a>
      <ul>
        <li><a href="#use-bitwarden-to-keep-your-secrets">Use Bitwarden to keep your secrets</a></li>
        <li><a href="#use-gopass-to-keep-your-secrets">Use gopass to keep your secrets</a></li>
        <li><a href="#use-gpg-to-keep-your-secrets">Use gpg to keep your secrets</a></li>
        <li><a href="#use-keepassxc-to-keep-your-secrets">Use KeePassXC to keep your secrets</a></li>
        <li><a href="#use-a-keyring-to-keep-your-secrets">Use a keyring to keep your secrets</a></li>
        <li><a href="#use-lastpass-to-keep-your-secrets">Use LastPass to keep your secrets</a></li>
        <li><a href="#use-1password-to-keep-your-secrets">Use 1Password to keep your secrets</a></li>
        <li><a href="#use-pass-to-keep-your-secrets">Use pass to keep your secrets</a></li>
        <li><a href="#use-vault-to-keep-your-secrets">Use Vault to keep your secrets</a></li>
        <li><a href="#use-a-generic-tool-to-keep-your-secrets">Use a generic tool to keep your secrets</a></li>
        <li><a href="#use-templates-variables-to-keep-your-secrets">Use templates variables to keep your secrets</a></li>
      </ul>
    </li>
    <li><a href="#use-scripts-to-perform-actions">Use scripts to perform actions</a>
      <ul>
        <li><a href="#understand-how-scripts-work">Understand how scripts work</a></li>
        <li><a href="#install-packages-with-scripts">Install packages with scripts</a></li>
      </ul>
    </li>
    <li><a href="#import-archives">Import archives</a></li>
    <li><a href="#export-archives">Export archives</a></li>
    <li><a href="#use-a-non-git-version-control-system">Use a non-git version control system</a></li>
    <li><a href="#customize-the-diff-command">Customize the <code>diff</code> command</a></li>
    <li><a href="#use-a-merge-tool-other-than-vimdiff">Use a merge tool other than vimdiff</a></li>
    <li><a href="#migrate-from-a-dotfile-manager-that-uses-symlinks">Migrate from a dotfile manager that uses symlinks</a></li>
  </ul>
</nav>
  </aside>



  </main>

  
</body>

</html>
